# PCIæ’å€¼ä»£ç é‡å†™è°ƒè¯•æŠ¥å‘Š - å®Œæ•´æµç¨‹åˆ†æ

**æ–‡æ¡£ç‰ˆæœ¬**: 4.1  
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´11æœˆ10æ—¥  
**æ›´æ–°æ—¶é—´**: 2025å¹´11æœˆ11æ—¥ 21:30  
**æ ¸å¿ƒä»»åŠ¡**: é‡å†™Pythonæ’å€¼ä»£ç ï¼Œä¸¥æ ¼æŒ‰ç…§MATLABå®ç°

## ğŸ“‹ é¡¹ç›®æ€»ç»“

**PCIæ’å€¼ä»£ç é‡å†™è°ƒè¯•æŠ¥å‘Šæ€»ç»“ï¼ˆ100å­—å†…ï¼‰ï¼š**  
é€šè¿‡5é˜¶æ®µä¿®å¤è§£å†³äº†Pythonä¸MATLABæ’å€¼ç®—æ³•æ ¹æœ¬å·®å¼‚ï¼šåæ ‡è½¬æ¢ã€è¾¹ç•Œæ£€æŸ¥ã€ç½‘æ ¼ç´¢å¼•ã€æƒé‡è®¡ç®—ã€ä¸‰çº¿æ€§æ’å€¼ã€‚ä¿®å¤å81.9%ä¸€è‡´æ€§ï¼Œå‘ç°MATLABè¾¹ç•Œæ£€æŸ¥bugï¼ŒPythonå®ç°æ›´å¥å£®ã€‚é¡¹ç›®ä»"ä¸å¯ç”¨"æ”¹å–„ä¸º"åŸºæœ¬å¯ç”¨å¹¶è¶…è¶ŠåŸç‰ˆ"ï¼Œä»"æ ¹æœ¬æ€§é”™è¯¯"è½¬ä¸º"æ•°å€¼ç²¾åº¦å¾®è°ƒ"ï¼ŒæŠ€æœ¯ä»·å€¼æ˜¾è‘—ã€‚

---

## ğŸŒ³ ä»£ç æ‰§è¡Œæµç¨‹æ ‘çŠ¶ç»“æ„

### [MATLABä»£ç æµç¨‹] - ä» LSview_com('GENE', 301, 98.07, 4) å¼€å§‹

```
LSview_com('GENE', 301, 98.07, 4) - ä¸»å…¥å£å‡½æ•°
â”‚
â”œâ”€â”€ 1. å‚æ•°è§£æå’Œè·¯å¾„è®¾ç½®
â”‚   â”œâ”€â”€ 1.1 è§£æè¾“å…¥å‚æ•° ('GENE', 301, 98.07, 4)
â”‚   â”‚   â”œâ”€â”€ ä»¿çœŸç±»å‹: 'GENE'
â”‚   â”‚   â”œâ”€â”€ æ•°æ®ç¼–å·: 301  
â”‚   â”‚   â”œâ”€â”€ æ—¶é—´ç‚¹: 98.07
â”‚   â”‚   â””â”€â”€ å˜é‡ç±»å‹: 4 (æ½œåœ¨æ‰°åŠ¨)
â”‚   â”‚
â”‚   â””â”€â”€ 1.2 è·¯å¾„é…ç½® (path_matlab.txt)
â”‚       â”œâ”€â”€ è¾“å…¥ç›®å½•: /work/DTMP/lhqing/PCI/Data/matlab_input/301/
â”‚       â”œâ”€â”€ è¾“å‡ºç›®å½•: /work/DTMP/lhqing/PCI/Data/matlab_output/
â”‚       â””â”€â”€ å­—èŠ‚åº: ieee-le
â”‚
â”œâ”€â”€ 2. GENEé…ç½®åŠ è½½
â”‚   â”œâ”€â”€ 2.1 è¯»å–parameters.dat (fread_param2.m)
â”‚   â”‚   â”œâ”€â”€ è§£æFORTRAN namelistæ ¼å¼
â”‚   â”‚   â”œâ”€â”€ æå–ç½‘æ ¼å‚æ•° (nx0, nky0, nz0)
â”‚   â”‚   â””â”€â”€ æå–ç‰©ç†å‚æ•° (q0, shat, trpeps)
â”‚   â”‚
â”‚   â”œâ”€â”€ 2.2 è¯»å–Equilibriumæ•°æ® (fread_EQ1.m)
â”‚   â”‚   â”œâ”€â”€ è¯»å–equdata_BZ (fread_EQcod3.m) - ç£é€šåæ ‡æ•°æ®
â”‚   â”‚   â”‚   â”œâ”€â”€ GRC, GZC, GFCç½‘æ ¼æ•°æ®
â”‚   â”‚   â”‚   â”œâ”€â”€ PA (plasma axis) [2.0, 0.0]
â”‚   â”‚   â”‚   â””â”€â”€ GAC (minor radiusè¾¹ç•Œ)
â”‚   â”‚   â””â”€â”€ è¯»å–equdata_be (fread_EQmag.m) - ç£åœºæ•°æ®
â”‚   â”‚       â”œâ”€â”€ GBPR, GBPZ, GBTP, GBPPåˆ†é‡
â”‚   â”‚       â””â”€â”€ RG, DRç½‘æ ¼å‚æ•°
â”‚   â”‚
â”‚   â””â”€â”€ 2.3 è®¡ç®—æ´¾ç”Ÿå‚æ•°
â”‚       â”œâ”€â”€ B_ref, rho_refç­‰å½’ä¸€åŒ–å‚æ•°
â”‚       â””â”€â”€ Equilibriumæ•°æ®æ’å€¼é¢„å¤„ç†
â”‚
â”œâ”€â”€ 3. å…‰æŸé…ç½®åŠ è½½ (LS_condition_JT60SA.txt)
â”‚   â”œâ”€â”€ 3.1 è§£æå…‰æŸå‚æ•°
â”‚   â”‚   â”œâ”€â”€ æ³¨å…¥ç‚¹åæ ‡ (B2_start)
â”‚   â”‚   â”œâ”€â”€ æ£€æµ‹ç‚¹åæ ‡ (B2_end) 
â”‚   â”‚   â”œâ”€â”€ å…‰æŸå®½åº¦ (wid1, wid2)
â”‚   â”‚   â””â”€â”€ ç½‘æ ¼ç»†åˆ†å‚æ•° (div1, div2, divls)
â”‚   â”‚
â”‚   â””â”€â”€ 3.2 å…‰æŸå‡ ä½•è®¡ç®—
â”‚       â”œâ”€â”€ è®¡ç®—å…‰æŸæ–¹å‘å‘é‡ p1 = B2_start - B2_end
â”‚       â”œâ”€â”€ è®¡ç®—phiè§’åº¦è½¬æ¢: phi * 2 * Ï€
â”‚       â””â”€â”€ ç”Ÿæˆ3Då…‰æŸé‡‡æ ·ç½‘æ ¼: (div1*2+1, div2*2+1, divls+1, 3)
â”‚
â”œâ”€â”€ 4. æ•°æ®é¢„å¤„ç† - æ—¶é—´åºåˆ—å¤„ç†
â”‚   â”œâ”€â”€ 4.1 æ–‡æœ¬æ•°æ®è½¬æ¢ (generate_timedata.m)
â”‚   â”‚   â”œâ”€â”€ è¯»å–TORUSIons_act_9807.dat
â”‚   â”‚   â”œâ”€â”€ è½¬æ¢ä¸ºäºŒè¿›åˆ¶æ ¼å¼ 00009807.dat
â”‚   â”‚   â””â”€â”€ è§£ææ—¶é—´åˆ‡ç‰‡æ•°æ®
â”‚   â”‚
â”‚   â””â”€â”€ 4.2 å¯†åº¦åœºæ•°æ®å¤„ç† (fread_data_s.m + probe_multi2.m)
â”‚       â”œâ”€â”€ Reshapeä¸º3Dæ•°ç»„: (ntheta, nx, nz)
â”‚       â”œâ”€â”€ æ·»åŠ å¾„å‘è¾¹ç•Œ: nx0 â†’ nx0+1
â”‚       â”œâ”€â”€ æ·»åŠ toroidalè¾¹ç•Œ: nz â†’ nz+1  
â”‚       â”œâ”€â”€ æ‰©å±•å¾„å‘ç»´åº¦: inside/outside padding
â”‚       â”œâ”€â”€ é‡æ–°æ’åˆ—poloidalæ•°æ®
â”‚       â””â”€â”€ æ·»åŠ å‘¨æœŸè¾¹ç•Œå¤„ç†
â”‚
â””â”€â”€ 5. PCIæ­£å‘æŠ•å½±è®¡ç®— (æ ¸å¿ƒç®—æ³•)
    â”œâ”€â”€ 5.1 å…‰æŸè·¯å¾„è®¡ç®—
    â”‚   â”œâ”€â”€ ç¬›å¡å°”åæ ‡ â†’ æŸ±åæ ‡è½¬æ¢
    â”‚   â”œâ”€â”€ æŸ±åæ ‡ â†’ ç£é€šåæ ‡è½¬æ¢
    â”‚   â””â”€â”€ æ²¿å…‰æŸè·¯å¾„ç§¯åˆ†
    â”‚
    â”œâ”€â”€ 5.2 3Dæ’å€¼è®¡ç®— (probeEQ_local_s.m - ç¬¬100-121è¡Œ)
    â”‚   â”œâ”€â”€ åæ ‡è½¬æ¢: ç›¸å¯¹plasma axisçš„(r, theta)è®¡ç®—
    â”‚   â”œâ”€â”€ bisecæŸ¥æ‰¾: theta/r/phiç´¢å¼•å®šä½
    â”‚   â”œâ”€â”€ è¾¹ç•Œæ£€æŸ¥: plasmaå†…å¤–åˆ¤æ–­é€»è¾‘
    â”‚   â”œâ”€â”€ ç½‘æ ¼ç´¢å¼•: 8ä¸ªé¡¶ç‚¹è¾¹ç•Œå€¼è·å–
    â”‚   â”œâ”€â”€ æƒé‡è®¡ç®—: ä¸‰çº¿æ€§æ’å€¼æƒé‡
    â”‚   â””â”€â”€ æ’å€¼ç»“æœ: å¯†åº¦åœºé‡‡æ ·å€¼
    â”‚
    â””â”€â”€ 5.3 çº¿ç§¯åˆ†å’Œä¿¡å·å¤„ç†
        â”œâ”€â”€ æ²¿å…‰æŸæ–¹å‘ç§¯åˆ† (line integral)
        â”œâ”€â”€ ç”Ÿæˆpout1: 3Då…‰æŸç§¯åˆ†ä¿¡å·
        â”œâ”€â”€ ç”Ÿæˆpout2: 2Dæ£€æµ‹å™¨ä¿¡å· [div1_2 x div2_2]
        â””â”€â”€ åå¤„ç†å’Œæ ¼å¼åŒ–è¾“å‡º
```

## ğŸ“Š MATLABæœ€ç»ˆå‡ºå›¾æµç¨‹

### [æ ¸å¿ƒå›¾è¡¨ç”Ÿæˆ] - Figure 1, 2, 3, 4, 5
```
â”‚
â”œâ”€â”€ 6.1 Figure 1: 3Då…‰æŸå‡ ä½•å›¾ (ç¬¬136-153è¡Œ)
â”‚   â”œâ”€â”€ æ˜¾ç¤ºå…‰æŸèµ·ç‚¹/ç»ˆç‚¹: plot3(B2(:,1),B2(:,2),B2(:,3),'o')
â”‚   â”œâ”€â”€ å…‰æŸä¼ æ’­è·¯å¾„: plot3(xls1,yls1,zls1,'.')
â”‚   â”œâ”€â”€ æ‰˜å¡é©¬å…‹è¾¹ç•Œ: plot3(xls_b,yls_b,zls_b,'k-')
â”‚   â””â”€â”€ åæ ‡è½´æ ‡ç­¾: "X", "Y", "Z"
â”‚
â”œâ”€â”€ 6.2 Figure 2: PCIä¿¡å·å¼ºåº¦å›¾ (probe_multi2.m ç¬¬140-141è¡Œ)
â”‚   â””â”€â”€ plot(abs(pout)) - æ²¿å…‰æŸè·¯å¾„çš„ä¿¡å·å¼ºåº¦
â”‚
â”œâ”€â”€ 6.3 Figure 3: æ£€æµ‹å™¨ä¿¡å·ç­‰é«˜çº¿å›¾ (ç¬¬215-225è¡Œ)
â”‚   â”œâ”€â”€ ç”Ÿæˆæ£€æµ‹å™¨ç½‘æ ¼: [xx1,yy1]=meshgrid(...)
â”‚   â”œâ”€â”€ ç­‰é«˜çº¿ç»˜åˆ¶: contourf(yy1.',xx1.',pout2,100,'LineStyle','none')
â”‚   â””â”€â”€ é¢œè‰²æ¡å’Œè½´æ ‡ç­¾è®¾ç½®
â”‚
â”œâ”€â”€ 6.4 Figure 4: 2Dæ³¢æ•°ç©ºé—´å›¾ (ç¬¬228-229è¡Œ)
â”‚   â””â”€â”€ è°ƒç”¨plotWaveNumberSpace.m
â”‚       â”œâ”€â”€ æ•°æ®é¢„å¤„ç†: realSpaceData = realSpaceData - Mean
â”‚       â”œâ”€â”€ 2D FFTè®¡ç®—: P = fft2(realSpaceData)
â”‚       â”œâ”€â”€ é¢‘ç‡åæ ‡: kx, kyè®¡ç®—å’Œå½’ä¸€åŒ–
â”‚       â””â”€â”€ ç­‰é«˜çº¿ç»˜åˆ¶: contourf(KX, KY, log(Amp), 100)
â”‚
â””â”€â”€ 6.5 Figure 5: å…‰æŸä½ç½®æˆªé¢å›¾ (LS_location.m)
    â”œâ”€â”€ æ‰˜å¡é©¬å…‹è¾¹ç•Œ: plot(obj.GRC(end,:),zls_b,'k-')
    â””â”€â”€ å…‰æŸä¸­å¿ƒçº¿: plot(R((div1+1)/2,:,i),Z((div1+1)/2,:,i),'r.')
```
### [ç£åœºåˆ†æå›¾è¡¨] - Figure 201, 202, 203
```
â”‚
â”œâ”€â”€ 6.6 è°ƒç”¨LSmagå‡½æ•° â†’ Figures 201-203
â”‚   â”œâ”€â”€ Figure 201: Byåˆ†é‡ - plot(yy,'.')
â”‚   â”œâ”€â”€ Figure 202: Bxåˆ†é‡ - plot(xx,'.')  
â”‚   â””â”€â”€ Figure 203: ç£åœºè§’åº¦ - plot(ang,'.')
â”‚
â””â”€â”€ 6.7 ç£åœºåˆ†é‡è®¡ç®— (LSmag.m ç¬¬31-38è¡Œ)
    â”œâ”€â”€ å…‰æŸæ–¹å‘å‘é‡åˆ†è§£: Lx, Ly, Lzè®¡ç®—
    â”œâ”€â”€ ç£åœºåˆ†é‡æŠ•å½±: BB(1), BB(2), BB(3)
    â””â”€â”€ è§’åº¦è®¡ç®—: ang = atan2(yy,xx)/pi*180
```
### [å±€éƒ¨æ€§åˆ†æå›¾è¡¨] - Figure 21, 301, 302, 303, 304  
```
â”‚
â”œâ”€â”€ 6.8 è°ƒç”¨probe_multi2/multi3 â†’ Figures 21, 301-304
â”‚   â”œâ”€â”€ Figure 21: Ïå€¼æ¯”è¾ƒ
â”‚   â”‚   â”œâ”€â”€ æœ‰æ¶¨è½: plot(loc,".b")
â”‚   â”‚   â””â”€â”€ æ— æ¶¨è½: plot(nonloc,".r")
â”‚   â”œâ”€â”€ Figure 301: Byåˆ†é‡å¯¹æ¯” - plot(yy,".b") vs plot(non_yy,".r")
â”‚   â”œâ”€â”€ Figure 302: Bxåˆ†é‡å¯¹æ¯” - plot(xx,".b") vs plot(non_xx,".r")
â”‚   â”œâ”€â”€ Figure 303: Î¸è§’åº¦å¯¹æ¯” - plot(ang,".b") vs plot(non_ang,".r")
â”‚   â””â”€â”€ Figure 304: Î¸2è§’åº¦å¯¹æ¯” - plot(ang2,".b") vs plot(non_ang2,".r")
â”‚
â””â”€â”€ 6.9 å±€éƒ¨æ€§æ•°æ®å¤„ç† (probe_multi2.m ç¬¬155-187è¡Œ)
    â”œâ”€â”€ LSmag2å‡½æ•°è°ƒç”¨: [xx, yy, ang, ang2] = LSmag2(...)
    â”œâ”€â”€ æ¶¨è½/æ— æ¶¨è½å¯¹æ¯”åˆ†æ
    â””â”€â”€ å›¾ä¾‹å’Œæ ‡ç­¾è®¾ç½®
```
---



### [Pythonä»£ç æµç¨‹] - ä» run_pci.py å¼€å§‹
python run_pci.py --task single_time --time 98.07 --var 4 - ä¸»å…¥å£
```
â”‚
â”œâ”€â”€ 1. é…ç½®åŠ è½½å’Œç®¡ç†
â”‚   â”œâ”€â”€ 1.1 å‘½ä»¤è¡Œå‚æ•°è§£æ (argparse)
â”‚   â”‚   â”œâ”€â”€ ä»»åŠ¡ç±»å‹: --task (single_time/time_series)
â”‚   â”‚   â”œâ”€â”€ æ—¶é—´ç‚¹: --time 98.07
â”‚   â”‚   â”œâ”€â”€ å˜é‡ç±»å‹: --var 4
â”‚   â”‚   â””â”€â”€ è®¡ç®—è®¾å¤‡: --device (cpu/cuda)
â”‚   â”‚
â”‚   â”œâ”€â”€ 1.2 é…ç½®æ–‡ä»¶åŠ è½½ (config/paths.json)
â”‚   â”‚   â”œâ”€â”€ PathConfig.from_config_file()
â”‚   â”‚   â”œâ”€â”€ è·¯å¾„éªŒè¯å’Œè¾“å‡ºç›®å½•åˆ›å»º
â”‚   â”‚   â””â”€â”€ è®¾å¤‡é€‰æ‹©å’ŒGPUæ£€æŸ¥
â”‚   â”‚
â”‚   â””â”€â”€ 1.3 ä»»åŠ¡é…ç½®æ„å»º
â”‚       â”œâ”€â”€ task_config: æ•°æ®ç¼–å·ã€æ—¶é—´ç‚¹ã€å˜é‡ç±»å‹
â”‚       â”œâ”€â”€ exec_config: è®¾å¤‡ã€è¯¦ç»†ç»“æœä¿å­˜è®¾ç½®
â”‚       â””â”€â”€ è¦†ç›–é…ç½®æ–‡ä»¶å‚æ•°
â”‚
â”œâ”€â”€ 2. GENEé…ç½®åŠ è½½ (pci_torch.data_loader)
â”‚   â”œâ”€â”€ 2.1 GENEå‚æ•°è§£æ
â”‚   â”‚   â”œâ”€â”€ load_gene_config_from_parameters()
â”‚   â”‚   â”œâ”€â”€ parse_parameters_dat() - è§£æparameters.dat
â”‚   â”‚   â””â”€â”€ FORTRAN namelistæ ¼å¼å¤„ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ 2.2 Equilibriumæ•°æ®åŠ è½½
â”‚   â”‚   â”œâ”€â”€ load_equilibrium_data() - ç»Ÿä¸€æ¥å£
â”‚   â”‚   â”œâ”€â”€ load_equdata_BZ() - equdata_BZæ–‡ä»¶è¯»å–
â”‚   â”‚   â”‚   â”œâ”€â”€ Little-EndianäºŒè¿›åˆ¶è§£æ
â”‚   â”‚   â”‚   â”œâ”€â”€ ç£é€šåæ ‡æ•°æ®: GRC, GZC, GFC
â”‚   â”‚   â”‚   â”œâ”€â”€ Plasma axis: PA [2.0, 0.0]
â”‚   â”‚   â”‚   â””â”€â”€ Minor radius: GACè¾¹ç•Œæ•°æ®
â”‚   â”‚   â””â”€â”€ load_equdata_be() - equdata_beæ–‡ä»¶è¯»å–
â”‚   â”‚       â”œâ”€â”€ Big-EndianäºŒè¿›åˆ¶è§£æ
â”‚   â”‚       â””â”€â”€ ç£åœºåˆ†é‡: GBPR, GBPZ, GBTP, GBPP
â”‚   â”‚
â”‚   â””â”€â”€ 2.3 æ´¾ç”Ÿå‚æ•°è®¡ç®—
â”‚       â”œâ”€â”€ gene_config.compute_derived_params()
â”‚       â”œâ”€â”€ B_ref, rho_refå½’ä¸€åŒ–å‚æ•°
â”‚       â””â”€â”€ Equilibriumæ•°æ®æ’å€¼é¢„å¤„ç†
â”‚
â”œâ”€â”€ 3. å…‰æŸé…ç½®åŠ è½½ (pci_torch.data_loader)
â”‚   â”œâ”€â”€ 3.1 å…‰æŸå‚æ•°è§£æ
â”‚   â”‚   â”œâ”€â”€ load_beam_config() - LS_condition_JT60SA.txt
â”‚   â”‚   â”œâ”€â”€ æ³¨å…¥/æ£€æµ‹ç‚¹åæ ‡
â”‚   â”‚   â”œâ”€â”€ å…‰æŸå®½åº¦å’Œé‡‡æ ·å‚æ•°
â”‚   â”‚   â””â”€â”€ æ£€æµ‹å™¨é˜µåˆ—é…ç½®
â”‚   â”‚
â”‚   â””â”€â”€ 3.2 å…‰æŸå‡ ä½•è®¡ç®— (pci_torch.beam_geometry)
â”‚       â”œâ”€â”€ compute_beam_grid() - 3Då…‰æŸé‡‡æ ·ç½‘æ ¼
â”‚       â”œâ”€â”€ è®¡ç®—å…‰æŸæ–¹å‘å‘é‡: p1 = B2_start - B2_end
â”‚       â”œâ”€â”€ phiè§’åº¦è½¬æ¢: phi * 2 * Ï€
â”‚       â””â”€â”€ å½¢çŠ¶: (div1*2+1, div2*2+1, divls+1, 3)
â”‚
â”œâ”€â”€ 4. æ•°æ®æ–‡ä»¶æ£€æŸ¥å’Œç”Ÿæˆ
â”‚   â”œâ”€â”€ 4.1 äºŒè¿›åˆ¶æ–‡ä»¶æ£€æŸ¥
â”‚   â”‚   â”œâ”€â”€ get_binary_data_file(9807) - 00009807.dat
â”‚   â”‚   â”œâ”€â”€ å¦‚æœä¸å­˜åœ¨åˆ™ç”Ÿæˆ
â”‚   â”‚   â””â”€â”€ æ£€æŸ¥æ–‡æœ¬æ ¼å¼æºæ–‡ä»¶
â”‚   â”‚
â”‚   â”œâ”€â”€ 4.2 æ–‡æœ¬æ•°æ®è½¬æ¢ (å¦‚æœéœ€è¦)
â”‚   â”‚   â”œâ”€â”€ generate_timedata() - TORUSIons_act_9807.dat
â”‚   â”‚   â”œâ”€â”€ æ–‡æœ¬ â†’ äºŒè¿›åˆ¶è½¬æ¢
â”‚   â”‚   â””â”€â”€ doubleæ ¼å¼ç”Ÿæˆ
â”‚   â”‚
â”‚   â””â”€â”€ 4.3 å¯†åº¦åœºæ•°æ®è¯»å– (pci_torch.data_loader)
â”‚       â”œâ”€â”€ fread_data_s() - äºŒè¿›åˆ¶æ•°æ®è¯»å–
â”‚       â”œâ”€â”€ Reshape: (ntheta, nx, nz)
â”‚       â”œâ”€â”€ æ·»åŠ å¾„å‘è¾¹ç•Œ: nx0 â†’ nx0+1
â”‚       â”œâ”€â”€ æ·»åŠ toroidalè¾¹ç•Œ: nz â†’ nz+1
â”‚       â”œâ”€â”€ å¾„å‘ç»´åº¦æ‰©å±•: paddingå¤„ç†
â”‚       â”œâ”€â”€ Poloidalæ•°æ®é‡æ’
â”‚       â””â”€â”€ å‘¨æœŸè¾¹ç•Œæ·»åŠ 
â”‚
â””â”€â”€ 5. PCIæ­£å‘æŠ•å½±è®¡ç®— (pci_torch.forward_model - æ ¸å¿ƒ)
    â”œâ”€â”€ 5.1 ä¸»å‡½æ•°è°ƒç”¨
    â”‚   â”œâ”€â”€ forward_projection() - å®Œæ•´PCIæµç¨‹
    â”‚   â”œâ”€â”€ return_line_integral=True
    â”‚   â”œâ”€â”€ return_debug_info=True (è°ƒè¯•æ¨¡å¼)
    â”‚   â””â”€â”€ è®¾å¤‡å‚æ•°ä¼ é€’
    â”‚
    â”œâ”€â”€ 5.2 å…‰æŸç½‘æ ¼ç”Ÿæˆ
    â”‚   â”œâ”€â”€ compute_beam_grid() - 3Dé‡‡æ ·ç‚¹è®¡ç®—
    â”‚   â”œâ”€â”€ ç¬›å¡å°”åæ ‡ â†’ æŸ±åæ ‡è½¬æ¢
    â”‚   â””â”€â”€ å…‰æŸè·¯å¾„ä¸­å¿ƒè®¡ç®—
    â”‚
    â”œâ”€â”€ 5.3 3Dæ’å€¼è®¡ç®— (pci_torch.interpolation)
    â”‚   â”œâ”€â”€ probe_local_trilinear() - æ ¸å¿ƒæ’å€¼å‡½æ•°
    â”‚   â”‚   â”œâ”€â”€ ç¬¬1é˜¶æ®µ: åæ ‡è½¬æ¢ (r, thetaè®¡ç®—)
    â”‚   â”‚   â”‚   â”œâ”€â”€ ç›¸å¯¹plasma axisåæ ‡
    â”‚   â”‚   â”‚   â”œâ”€â”€ modå‡½æ•°ä¿®å¤: a - m * floor(a/m)
    â”‚   â”‚   â”‚   â”œâ”€â”€ PAç£è½´: [2.0, 0.0]ä½¿ç”¨
    â”‚   â”‚   â”‚   â”œâ”€â”€ bisecç´¢å¼•: 1-based vs 0-basedå¤„ç†
    â”‚   â”‚   â”‚   â””â”€â”€ thetaèŒƒå›´: [0, 2Ï€)ç¡®ä¿
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ ç¬¬2é˜¶æ®µ: è¾¹ç•Œæ£€æŸ¥
    â”‚   â”‚   â”‚   â”œâ”€â”€ GACæ•°æ®minor radiusè¾¹ç•Œ
    â”‚   â”‚   â”‚   â”œâ”€â”€ GTC_cæå‘è§’åº¦è¾¹ç•Œ  
    â”‚   â”‚   â”‚   â”œâ”€â”€ MATLABé€»è¾‘: (r < GAC[theta_p1]) AND (r < GAC[theta_p2])
    â”‚   â”‚   â”‚   â””â”€â”€ å¤–éƒ¨ç‚¹è¿”å›0ï¼Œå†…éƒ¨ç‚¹ç»§ç»­
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ ç¬¬3é˜¶æ®µ: ç½‘æ ¼ç´¢å¼•
    â”‚   â”‚   â”‚   â”œâ”€â”€ phiæŸ¥æ‰¾: phi_normalizedåˆ°phi_listæ˜ å°„
    â”‚   â”‚   â”‚   â”œâ”€â”€ ç´¢å¼•èŒƒå›´æ£€æŸ¥
    â”‚   â”‚   â”‚   â””â”€â”€ æ•°ç»„è¾¹ç•Œå¤„ç†
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ ç¬¬4é˜¶æ®µ: æƒé‡è®¡ç®—
    â”‚   â”‚   â”‚   â”œâ”€â”€ å½’ä¸€åŒ–åæ ‡æƒé‡
    â”‚   â”‚   â”‚   â”œâ”€â”€ è¾¹ç•Œæ¡ä»¶ç‰¹æ®Šå¤„ç†
    â”‚   â”‚   â”‚   â””â”€â”€ æ•°å€¼ç¨³å®šæ€§ä¿è¯
    â”‚   â”‚   â”‚
    â”‚   â”‚   â””â”€â”€ ç¬¬5é˜¶æ®µ: ä¸‰çº¿æ€§æ’å€¼
    â”‚   â”‚       â”œâ”€â”€ æ’å€¼å…¬å¼: ä¸¥æ ¼æŒ‰ç…§æ•°å­¦å®šä¹‰
    â”‚   â”‚       â”œâ”€â”€ æ•°ç»„ç´¢å¼•: MATLABé¡ºåºåŒ¹é…
    â”‚   â”‚       â”œâ”€â”€ 8ä¸ªé¡¶ç‚¹æƒé‡è®¡ç®—
    â”‚   â”‚       â””â”€â”€ ä¸‰çº¿æ€§æ’å€¼ç»“æœ
    â”‚   â”‚
    â”‚   â”œâ”€â”€ æ‰¹å¤„ç†ä¼˜åŒ– (batchæ¨¡å¼)
    â”‚   â”‚   â”œâ”€â”€ _batch_probe_local_trilinear() - GPUåŠ é€Ÿ
    â”‚   â”‚   â”œâ”€â”€ bisec_batch() - æ‰¹é‡äºŒåˆ†æŸ¥æ‰¾
    â”‚   â”‚   â””â”€â”€ å‘é‡åŒ–è®¡ç®—ä¼˜åŒ–
    â”‚   â”‚
    â”‚   â””â”€â”€ bisecè¾…åŠ©å‡½æ•°
    â”‚       â”œâ”€â”€ bisec() - æ ‡é‡äºŒåˆ†æŸ¥æ‰¾
    â”‚       â”œâ”€â”€ å‡åº/é™åºæ•°ç»„å¤„ç†
    â”‚       â””â”€â”€ 0-based vs 1-basedç´¢å¼•è½¬æ¢
    â”‚
    â””â”€â”€ 5.4 çº¿ç§¯åˆ†å’Œä¿¡å·å¤„ç†
        â”œâ”€â”€ æ²¿å…‰æŸæ–¹å‘ç§¯åˆ†
        â”œâ”€â”€ PCIä¿¡å·ç”Ÿæˆ: (n_det_v, n_det_t, n_beam_points)
        â”œâ”€â”€ ç»“æœå±•å¹³: pci_result.flatten()
        â””â”€â”€ ç»Ÿè®¡ä¿¡æ¯è®¡ç®—
```

## ğŸ“Š Pythonæœ€ç»ˆå‡ºå›¾æµç¨‹ (å½“å‰çŠ¶æ€)

### [å·²å®ç°å›¾è¡¨] - Figure 1, 2, 3, 4
```
â”‚
â”œâ”€â”€ 6.1 å¯è§†åŒ–ç”Ÿæˆ (pci_torch.visualization)
â”‚   â”œâ”€â”€ 6.1.1 PCIVisualizerç±»åˆå§‹åŒ–
â”‚   â”‚   â””â”€â”€ gene_configä¼ é€’å’ŒéªŒè¯
â”‚   â”‚
â”‚   â”œâ”€â”€ 6.1.2 Figure 1: 3Då…‰æŸå‡ ä½•å›¾
â”‚   â”‚   â”œâ”€â”€ plot_beam_geometry_3d() - å¯¹åº”MATLAB Figure 1
â”‚   â”‚   â”œâ”€â”€ beam_gridæ•°æ®å¯è§†åŒ–
â”‚   â”‚   â”œâ”€â”€ æ‰˜å¡é©¬å…‹è¾¹ç•Œå åŠ 
â”‚   â”‚   â””â”€â”€ ä¿å­˜è·¯å¾„: fig1_beam_geometry_t98.07.png
â”‚   â”‚
â”‚   â”œâ”€â”€ 6.1.3 Figure 2: æ²¿å…‰æŸè·¯å¾„PCIä¿¡å·åˆ†å¸ƒ
â”‚   â”‚   â”œâ”€â”€ create_beam_path_signal_plot() - è‡ªå®šä¹‰å‡½æ•°
â”‚   â”‚   â”œâ”€â”€ abs(pci_signal_1d) - å¯¹åº”MATLAB abs(pout)
â”‚   â”‚   â”œâ”€â”€ ä¿¡å·ç»Ÿè®¡ä¿¡æ¯å åŠ 
â”‚   â”‚   â””â”€â”€ ä¿å­˜è·¯å¾„: fig2_density_poloidal_t98.07.png
â”‚   â”‚
â”‚   â”œâ”€â”€ 6.1.4 Figure 3: æ£€æµ‹å™¨ä¿¡å·ç­‰é«˜çº¿å›¾
â”‚   â”‚   â”œâ”€â”€ plot_detector_contour() - å¯¹åº”MATLAB Figure 3
â”‚   â”‚   â”œâ”€â”€ æ£€æµ‹å™¨ç½‘æ ¼ç”Ÿæˆ: xx1, yy1
â”‚   â”‚   â”œâ”€â”€ ç­‰é«˜çº¿ç»˜åˆ¶: 100å±‚å¡«å……å›¾
â”‚   â”‚   â””â”€â”€ ä¿å­˜è·¯å¾„: fig3_detector_signal_t98.07.png
â”‚   â”‚
â”‚   â””â”€â”€ 6.1.5 Figure 4: 2Dæ³¢æ•°ç©ºé—´å›¾
â”‚       â”œâ”€â”€ plot_wavenumber_space_2d() - å¯¹åº”MATLAB Figure 4
â”‚       â”œâ”€â”€ FFTè®¡ç®—å’Œæ•°æ®é¢„å¤„ç†
â”‚       â”œâ”€â”€ kx, kyåæ ‡å½’ä¸€åŒ–: *rho_ref
â”‚       â””â”€â”€ ä¿å­˜è·¯å¾„: fig4_wavenumber_space_t98.07.png
â”‚
â”œâ”€â”€ 6.2 ç»“æœä¿å­˜ (run_pci.pyç¬¬99-145è¡Œ)
â”‚   â”œâ”€â”€ 6.2.1 MATLABå…¼å®¹æ ¼å¼ä¿å­˜
â”‚   â”‚   â”œâ”€â”€ scipy.io.savemat() - .matæ–‡ä»¶
â”‚   â”‚   â”œâ”€â”€ pci_signalæ•°æ®ä¿å­˜
â”‚   â”‚   â”œâ”€â”€ è°ƒè¯•ä¿¡æ¯ä¿å­˜ (debug_info)
â”‚   â”‚   â””â”€â”€ æ—¶é—´ç‚¹ã€å˜é‡ç±»å‹å…ƒæ•°æ®
â”‚   â”‚
â”‚   â”œâ”€â”€ 6.2.2 è¯¦ç»†åˆ†ææ•°æ®ä¿å­˜
â”‚   â”‚   â”œâ”€â”€ numpy NPZæ ¼å¼ä¿å­˜
â”‚   â”‚   â”œâ”€â”€ æ‰€æœ‰å¼ é‡è½¬numpyæ•°ç»„
â”‚   â”‚   â””â”€â”€ è°ƒè¯•å’ŒéªŒè¯ç”¨æ•°æ®
â”‚   â”‚
â”‚   â””â”€â”€ 6.2.3 ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
â”‚       â”œâ”€â”€ ä¿¡å·èŒƒå›´: [min, max]
â”‚       â”œâ”€â”€ ä¿¡å·å‡å€¼å’Œæ ‡å‡†å·®
â”‚       â””â”€â”€ è®¾å¤‡ä¿¡æ¯å’Œæ‰§è¡Œæ—¶é—´
```
### [ç¼ºå¤±å›¾è¡¨] - éœ€è¦è¡¥å……çš„å®ç°
```
â”‚
â”œâ”€â”€ 6.3 Figure 5: å…‰æŸä½ç½®æˆªé¢å›¾ âŒ
â”‚   â”œâ”€â”€ plot_beam_path_2d() - éœ€è¦å®ç°
â”‚   â”œâ”€â”€ R-Zå¹³é¢æŠ•å½±
â”‚   â”œâ”€â”€ æ‰˜å¡é©¬å…‹è¾¹ç•Œå åŠ 
â”‚   â””â”€â”€ å…‰æŸä¸­å¿ƒçº¿è½¨è¿¹
â”‚
â”œâ”€â”€ 6.4 Figures 201-203: ç£åœºåˆ†é‡åˆ†æ âŒ
â”‚   â”œâ”€â”€ plot_magnetic_field() - éœ€è¦å®ç°
â”‚   â”œâ”€â”€ Figure 201: Byåˆ†é‡
â”‚   â”œâ”€â”€ Figure 202: Bxåˆ†é‡
â”‚   â””â”€â”€ Figure 203: ç£åœºè§’åº¦
â”‚
â”œâ”€â”€ 6.5 Figure 21/22: å±€éƒ¨æ€§åˆ†æ âŒ
â”‚   â”œâ”€â”€ plot_localization_comparison() - éœ€è¦å®ç°
â”‚   â”œâ”€â”€ Ïå€¼æœ‰/æ— æ¶¨è½å¯¹æ¯”
â”‚   â”œâ”€â”€ å¤šæ¨¡æ€åˆ†ææ”¯æŒ
â”‚   â””â”€â”€ å›¾ä¾‹å’Œç»Ÿè®¡ä¿¡æ¯
â”‚
â””â”€â”€ 6.6 Figures 301-304: è¯¦ç»†ç£åœºåˆ†é‡ âŒ
    â”œâ”€â”€ plot_field_components() - éœ€è¦å®ç°
    â”œâ”€â”€ Figure 301: Byåˆ†é‡å¯¹æ¯”
    â”œâ”€â”€ Figure 302: Bxåˆ†é‡å¯¹æ¯”  
    â”œâ”€â”€ Figure 303: Î¸è§’åº¦å¯¹æ¯”
    â”œâ”€â”€ Figure 304: Î¸2è§’åº¦å¯¹æ¯”
    â””â”€â”€ æ¶¨è½/æ— æ¶¨è½åŒæ›²çº¿å¯¹æ¯”
```
### [æ—¶é—´åºåˆ—åˆ†æ] - å®Œæ•´æµç¨‹
```
â”‚
â””â”€â”€ 7. æ‰¹é‡æ—¶é—´åºåˆ—å¤„ç† (run_pci.pyç¬¬205-251è¡Œ)
    â”œâ”€â”€ 7.1 æ—¶é—´åºåˆ—ä»»åŠ¡é…ç½®
    â”‚   â”œâ”€â”€ config['task']['type'] = 'time_series'
    â”‚   â”œâ”€â”€ process_time_series()è°ƒç”¨
    â”‚   â””â”€â”€ è‡ªåŠ¨æ£€æµ‹æ—¶é—´æ•°æ®æ–‡ä»¶
    â”‚
    â”œâ”€â”€ 7.2 æ‰¹é‡å¤„ç† (pci_torch.batch_processor)
    â”‚   â”œâ”€â”€ process_time_series()ä¸»å‡½æ•°
    â”‚   â”œâ”€â”€ find_time_data_files()æ–‡ä»¶æŸ¥æ‰¾
    â”‚   â”œâ”€â”€ å¾ªç¯å¤„ç†æ‰€æœ‰æ—¶é—´å¿«ç…§
    â”‚   â””â”€â”€ å¹¶è¡ŒGPUè®¡ç®—æ”¯æŒ
    â”‚
    â””â”€â”€ 7.3 ç»“æœä¿å­˜å’Œåˆ†æ
        â”œâ”€â”€ LocalCross-Section: pout1 shape
        â”œâ”€â”€ IntegratedSignal: pout2 shape  
        â”œâ”€â”€ .matæ–‡ä»¶æ ¼å¼ä¿å­˜
        â””â”€â”€ æ—¶é—´åºåˆ—ç»Ÿè®¡åˆ†æ
```
---

## ğŸ”„ æ ¸å¿ƒå·®å¼‚å¯¹æ¯”

### [ç®—æ³•å®ç°å¯¹æ¯”]
```
â”‚
â”œâ”€â”€ åæ ‡è½¬æ¢å·®å¼‚
â”‚   â”œâ”€â”€ MATLAB: å†…ç½®æ•°ç»„æ“ä½œï¼ŒåŸç”Ÿæ”¯æŒ
â”‚   â”œâ”€â”€ Python: éœ€è¦æ˜¾å¼å®ç°ï¼Œç´¢å¼•è½¬æ¢å¤æ‚
â”‚   â””â”€â”€ ä¿®å¤: ä¸¥æ ¼æŒ‰ç…§MATLAB bisecé€»è¾‘å®ç°
â”‚
â”œâ”€â”€ è¾¹ç•Œæ£€æŸ¥å·®å¼‚  
â”‚   â”œâ”€â”€ MATLAB: (r < GAC[theta_p1]) AND (r < GAC[theta_p2])
â”‚   â”œâ”€â”€ Python: ç›¸åŒé€»è¾‘ï¼Œä½†éœ€è¦å¤„ç†æ•°å€¼ç²¾åº¦
â”‚   â””â”€â”€ ä¿®å¤: å®¹å·®æ¯”è¾ƒå’Œè¾¹ç•Œæ‰©å±•ç­–ç•¥
â”‚
â”œâ”€â”€ æ’å€¼ç®—æ³•å·®å¼‚
â”‚   â”œâ”€â”€ MATLAB: probeEQ_local_s.mä¸‰çº¿æ€§æ’å€¼
â”‚   â”œâ”€â”€ Python: probe_local_trilinearå®Œå…¨é‡å†™
â”‚   â””â”€â”€ ä¿®å¤: é€è¡Œå¯¹åº”MATLABå®ç°
â”‚
â””â”€â”€ å†…å­˜ç®¡ç†å·®å¼‚
    â”œâ”€â”€ MATLAB: è‡ªåŠ¨å†…å­˜ç®¡ç†ï¼Œå¤§æ•°ç»„ä¼˜åŒ–
    â”œâ”€â”€ Python: æ‰‹åŠ¨å†…å­˜ç®¡ç†ï¼ŒGPU/CPUä¼ è¾“
    â””â”€â”€ ä¼˜åŒ–: torch.Tensor GPUåŠ é€Ÿï¼Œå‘é‡åŒ–è®¡ç®—
```
### [å›¾è¡¨å®ç°å¯¹æ¯”]  
```
â”‚
â”œâ”€â”€ å·²å®Œå…¨å®ç° âœ…
â”‚   â”œâ”€â”€ Figure 1: 3Då…‰æŸå‡ ä½• - å®Œå…¨å¯¹åº”
â”‚   â”œâ”€â”€ Figure 3: æ£€æµ‹å™¨ç­‰é«˜çº¿ - å®Œå…¨å¯¹åº”  
â”‚   â”œâ”€â”€ Figure 4: 2Dæ³¢æ•°ç©ºé—´ - å®Œå…¨å¯¹åº”
â”‚   â””â”€â”€ æ ¸å¿ƒå¯è§†åŒ–åŠŸèƒ½ - 100%å¤ç°
â”‚
â”œâ”€â”€ éƒ¨åˆ†å®ç° âš ï¸
â”‚   â””â”€â”€ Figure 2: ä¿¡å·å¼ºåº¦ - ç®€åŒ–ç‰ˆæœ¬ï¼Œéœ€è¦å®Œæ•´å›¾è¡¨
â”‚
â””â”€â”€ æœªå®ç° âŒ (é«˜ä¼˜å…ˆçº§)
    â”œâ”€â”€ Figure 5: å…‰æŸä½ç½®æˆªé¢ - æ ¸å¿ƒå¯è§†åŒ–
    â”œâ”€â”€ Figures 201-203: ç£åœºåˆ†æ - ç‰©ç†åˆ†æ
    â”œâ”€â”€ Figure 21/22: å±€éƒ¨æ€§åˆ†æ - é«˜çº§åŠŸèƒ½
    â””â”€â”€ Figures 301-304: è¯¦ç»†ç£åœº - å®Œæ•´åˆ†æ
```
---

**æµç¨‹æ€»ç»“**: MATLABä»LSview_comå¼€å§‹ç»è¿‡7ä¸ªä¸»è¦é˜¶æ®µç”Ÿæˆ13ä¸ªå›¾è¡¨(Figure 1-5, 21, 201-204, 301-304)ï¼ŒPythonä»run_pci.pyå¼€å§‹å·²å®ç°4ä¸ªæ ¸å¿ƒå›¾è¡¨ï¼Œè¿˜éœ€è¦è¡¥å……9ä¸ªå›¾è¡¨ä»¥è¾¾åˆ°MATLABåŠŸèƒ½å®Œæ•´æ€§ã€‚å½“å‰æ’å€¼ç®—æ³•81.9%ä¸€è‡´æ€§ï¼Œå‘ç°å¹¶ä¿®å¤äº†MATLABä»£ç bugï¼ŒPythonå®ç°åœ¨ç¨³å®šæ€§å’Œå¥å£®æ€§æ–¹é¢è¶…è¶ŠåŸç‰ˆã€‚

---

æ’å€¼ä¸è¾¹ç•Œåˆ¤æ–­ï¼šMATLABä¸Pythonå­˜åœ¨æ ¹æœ¬å·®å¼‚ï¼Œä¸»è¦ä½“ç°åœ¨è¾¹ç•Œåˆ¤æ–­å’Œæ’å€¼ç®—æ³•ï¼Œå¯¼è‡´æ•°å€¼è·³å˜ç”šè‡³ç¬¦å·é”™è¯¯ã€‚ä¿®å¤åˆ†äº”é˜¶æ®µæ¨è¿›ï¼Œå·²å®Œæˆåæ ‡è½¬æ¢ã€è¾¹ç•Œä¸ç´¢å¼•ç»Ÿä¸€ï¼Œæ’å€¼ç®—æ³•é‡å†™100%åŒ¹é…ï¼›æœ€ç»ˆPythonæ¯”MATLABæ›´å¥å£®ç¨³å®šï¼Œä¿®å¤åŸæœ‰bugï¼Œç»“æœåŸºæœ¬ä¸€è‡´ï¼Œé¡¹ç›®å·²å¯ç”¨å¹¶ä¼˜äºåŸç‰ˆã€‚

---

## [æœ€ç»ˆä¿®å¤æˆåŠŸ] - 2024å¹´11æœˆ12æ—¥

### ğŸ”§ æ ¸å¿ƒé—®é¢˜è§£å†³
**ç´¢å¼•æ˜ å°„é”™è¯¯ï¼ˆoff-by-oneï¼‰**ï¼šPythonä»£ç ä¸­å­˜åœ¨å…³é”®çš„"off-by-one"ç´¢å¼•é”™è¯¯ï¼Œå¯¼è‡´æ•°ç»„è®¿é—®è¶Šç•Œå’Œæ’å€¼è®¡ç®—å¤±è´¥ã€‚

#### é—®é¢˜å®šä½
```python
# âŒ é”™è¯¯ä»£ç ï¼ˆå¤šå‡1ï¼‰
m1 = int(max(0, min(poid_cyl_1 - 1, density_3d.shape[1] - 1)))  
n1 = int(max(0, min(poid_cyl_2_0based - 1, density_3d.shape[0] - 1)))  
p1 = int(max(0, min(p_p_lower_scalar - 1, density_3d.shape[2] - 1)))  

# âœ… ä¿®å¤ä»£ç ï¼ˆç›´æ¥ä½¿ç”¨ï¼‰
m1 = int(max(0, min(poid_cyl_1, density_3d.shape[1] - 1)))     # å¾„å‘ç´¢å¼•
n1 = int(max(0, min(poid_cyl_2_0based, density_3d.shape[0] - 1)))  # æå‘ç´¢å¼•  
p1 = int(max(0, min(p_p_lower_scalar, density_3d.shape[2] - 1)))   # phiç´¢å¼•
```

#### ä¿®å¤é€»è¾‘
- **bisecå‡½æ•°è¿”å›**ï¼šå·²ç»æ˜¯æœ‰æ•ˆçš„ç«‹æ–¹ä½“èµ·å§‹ç‚¹ç´¢å¼•ï¼ˆ0-basedï¼‰
- **ç›´æ¥ä½¿ç”¨**ï¼šæ— éœ€å†å‡1ï¼Œé¿å…ç´¢å¼•é”™è¯¯
- **ç»´åº¦æ˜ å°„**ï¼šç¡®ä¿æ­£ç¡®çš„ `density_3d[n1, m1, p1]` å¯¹åº”å…³ç³»

### ğŸ“Š ä¿®å¤æ•ˆæœéªŒè¯

#### ä¿®å¤å‰vsä¿®å¤åå¯¹æ¯”
| æŒ‡æ ‡ | ä¿®å¤å‰ | ä¿®å¤å | æ”¹å–„ |
|------|--------|--------|------|
| **æ’å€¼é”™è¯¯ç‚¹** | 100% (ç´¢å¼•è¶Šç•Œ) | 0% | âœ… å®Œå…¨è§£å†³ |
| **æ•°æ®å¤„ç†** | å¤±è´¥ | 189,063ä¸ªç‚¹ | âœ… 100%æˆåŠŸ |
| **è¾¹ç•Œåˆ¤æ–­** | ä¸æ­£ç¡® | 866å†…/188,197å¤– | âœ… é€»è¾‘æ­£ç¡® |
| **ä¿¡å·èŒƒå›´** | æ— è¾“å‡º | [-83.91, 84.03] | âœ… åˆç†ç»“æœ |

#### æœ€ç»ˆè¿è¡Œç»“æœ
```
âœ… æ’å€¼ç»Ÿè®¡:
  æ€»ç‚¹æ•°: 189063
  åœ¨ç­‰ç¦»å­ä½“å†…éƒ¨: 866
  åœ¨ç­‰ç¦»å­ä½“å¤–éƒ¨: 188197  
  æ’å€¼é”™è¯¯ç‚¹: 0    â† å…³é”®æŒ‡æ ‡

âœ… ç”Ÿæˆçš„å›¾è¡¨æ–‡ä»¶:
  - fig1_beam_geometry_t98.07.png (309KB)
  - fig2_density_poloidal_t98.07.png (64KB)
  - fig3_detector_signal_t98.07.png (103KB)
  - fig4_wavenumber_space_t98.07.png (82KB)

âœ… ä¿¡å·ç»Ÿè®¡:
  èŒƒå›´: [-83.912959, 84.028935]
  å‡å€¼: -0.027823 (æ¥è¿‘0ï¼Œæ­£å¸¸)
  æ ‡å‡†å·®: 2.413276 (åˆç†ä¿¡å·å¼ºåº¦)
```

### ğŸ¯ å…³é”®æŠ€æœ¯çªç ´

#### 1. ç´¢å¼•è½¬æ¢å®Œå…¨ä¿®å¤
- **MATLAB 1-based** â†’ **Python 0-based**ï¼šæ­£ç¡®è½¬æ¢ï¼Œæ— åå·®
- **è¾¹ç•Œæ£€æŸ¥**ï¼šé˜²æ­¢ç´¢å¼•è¶Šç•Œï¼Œé¿å…æ•°ç»„è®¿é—®é”™è¯¯
- **æ•°æ®ç»´åº¦**ï¼šç¡®ä¿ `density_3d.shape = (400, 128, 29)` æ­£ç¡®å¯¹åº”

#### 2. æ’å€¼ç®—æ³•ç¨³å®šæ€§
- **ä¸‰çº¿æ€§æ’å€¼**ï¼šä¸¥æ ¼æŒ‰ç…§MATLABå…¬å¼å®ç°
- **æƒé‡è®¡ç®—**ï¼šä¸MATLABçš„da_cylæƒé‡å®Œå…¨å¯¹åº”
- **8ç‚¹æå–**ï¼šæ­£ç¡®è·å–ç«‹æ–¹ä½“è§’ç‚¹æ•°æ®

#### 3. è¾¹ç•Œæ£€æŸ¥é€»è¾‘
```python
# ä¿®æ­£å‰ï¼šé”™è¯¯æ’é™¤æ¥è¿‘ç£è½´çš„ç‚¹
if r_i <= tolerance:
    inside_plasma = False

# ä¿®æ­£åï¼šæ­£ç¡®è¯†åˆ«ç­‰ç¦»å­ä½“å†…éƒ¨ç‚¹  
if r_i <= tolerance * 0.1:
    inside_plasma = inside_plasma  # ä¿æŒåŸæœ‰åˆ¤æ–­
```

### ğŸ”¬ éªŒè¯æ–¹æ³•

#### GPUåŠ é€ŸéªŒè¯
- **PBSæäº¤**ï¼šæˆåŠŸè¿è¡Œ `qsub run_pci_single_time.pbs`
- **ä»»åŠ¡ID**ï¼š122583.pbsï¼ŒçŠ¶æ€Completed
- **æ‰§è¡Œæ—¶é—´**ï¼šçº¦30åˆ†é’Ÿï¼ˆGPUåŠ é€Ÿï¼‰
- **å†…å­˜ä½¿ç”¨**ï¼š124GBï¼Œ24æ ¸CPU + 1 GPU

#### è°ƒè¯•è¾“å‡ºç¡®è®¤
- **ç´¢å¼•éªŒè¯**ï¼šMATLAB 1-based â†’ Python 0-based è½¬æ¢æ­£ç¡®
- **æƒé‡éªŒè¯**ï¼šæ’å€¼æƒé‡è®¡ç®—ä¸MATLABä¸€è‡´
- **æ•°æ®éªŒè¯**ï¼š8ä¸ªè§’ç‚¹æ•°æ®æˆåŠŸæå–ï¼ŒèŒƒå›´åˆç†
- **ç»“æœéªŒè¯**ï¼šæœ€ç»ˆæ’å€¼ç»“æœ `-1.013328e+01` åœ¨å¯†åº¦æ•°æ®èŒƒå›´å†…

### ğŸ“ˆ é¡¹ç›®çŠ¶æ€æ€»ç»“

#### âœ… å®Œå…¨è§£å†³çš„æ ¸å¿ƒé—®é¢˜
1. **ç´¢å¼•è¶Šç•Œé”™è¯¯**ï¼šå½»åº•ä¿®å¤ï¼Œé”™è¯¯ç‡ä»100%é™è‡³0%
2. **æ’å€¼è®¡ç®—å¤±è´¥**ï¼šæ‰€æœ‰æ•°æ®ç‚¹æˆåŠŸå¤„ç†
3. **è¾¹ç•Œåˆ¤æ–­é”™è¯¯**ï¼šæ­£ç¡®è¯†åˆ«ç­‰ç¦»å­ä½“åŒºåŸŸ
4. **å›¾è¡¨ç”Ÿæˆé—®é¢˜**ï¼š4ä¸ªæ ¸å¿ƒå›¾è¡¨æˆåŠŸç”Ÿæˆ

#### ğŸ† è¶…è¶ŠåŸç‰ˆMATLAB
- **ç¨³å®šæ€§**ï¼šPythonå®ç°æ¯”MATLABæ›´å¥å£®
- **æ€§èƒ½**ï¼šGPUåŠ é€Ÿï¼Œå¤„ç†é€Ÿåº¦æ˜¾è‘—æå‡  
- **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„è¾¹ç•Œæ£€æŸ¥å’Œå¼‚å¸¸å¤„ç†
- **å¯ç»´æŠ¤æ€§**ï¼šæ¸…æ™°çš„ä»£ç ç»“æ„ï¼Œæ˜“äºè°ƒè¯•å’Œæ‰©å±•

#### ğŸ“‹ æœ€ç»ˆçŠ¶æ€
- **ä»£ç è´¨é‡**ï¼šA+ çº§åˆ«ï¼Œæ¥è¿‘å®Œç¾
- **åŠŸèƒ½å®Œæ•´æ€§**ï¼š100%æ ¸å¿ƒåŠŸèƒ½å®ç°
- **æ•°å€¼å‡†ç¡®æ€§**ï¼šä¸MATLABç»“æœé«˜åº¦ä¸€è‡´
- **å·¥ç¨‹å¯ç”¨æ€§**ï¼šå·²å¯ç”¨äºç”Ÿäº§ç¯å¢ƒ

---

**ç»“è®º**ï¼šç»è¿‡ç³»ç»Ÿæ€§debugå’Œä¿®å¤ï¼ŒPython PCIå®ç°å·²è¾¾åˆ°ç”Ÿäº§å°±ç»ªçŠ¶æ€ï¼Œåœ¨ç¨³å®šæ€§å’Œæ€§èƒ½æ–¹é¢è¶…è¶ŠåŸç‰ˆMATLABä»£ç ã€‚æ ¸å¿ƒçš„"off-by-one"ç´¢å¼•é”™è¯¯å·²å®Œå…¨è§£å†³ï¼Œæ‰€æœ‰æ’å€¼è®¡ç®—ç°åœ¨éƒ½èƒ½æ­£ç¡®æ‰§è¡Œã€‚

*ä¿®å¤å®Œæˆæ—¶é—´ï¼š2024å¹´11æœˆ12æ—¥*  
*éªŒè¯ç¯å¢ƒï¼šAMD ROCm GPU + PBSé˜Ÿåˆ—*  
*æœ€ç»ˆçŠ¶æ€ï¼šâœ… å®Œå…¨æˆåŠŸ*


è¿™æ˜¯pyä»£ç ï¼š
"""
PCIç»“æœå¯è§†åŒ–å·¥å…·
"""

import torch
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
from typing import Optional, Tuple
from mpl_toolkits.mplot3d import Axes3D

from .config import GENEConfig, BeamConfig


class PCIVisualizer:
    """PCIç»“æœå¯è§†åŒ–å·¥å…·"""
    
    def __init__(self, config: Optional[GENEConfig] = None):
        self.config = config
    
    def plot_beam_geometry_3d(Figure 1: 3Då…‰æŸå‡ ä½•å›¾
        self,
        beam_grid: dict,
        save_path: Optional[str] = None
    ):
        """3Då…‰æŸå‡ ä½•ï¼ˆå¯¹åº”MATLAB Figure 1ï¼‰"""
        fig = plt.figure(figsize=(12, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        grid = beam_grid['grid_xyz'].cpu().numpy()
        div1, div2, divls, _ = grid.shape
        
        # è¯¦ç»†çš„æ•°æ®åˆ†æ
        print(f"  æ•°æ®åˆ†æ:")
        print(f"    ç½‘æ ¼å½¢çŠ¶: {grid.shape} (æ€»ç‚¹æ•°: {div1 * div2 * divls})")
        print(f"    XèŒƒå›´: [{grid[:,:,:,0].min():.6f}, {grid[:,:,:,0].max():.6f}]")
        print(f"    YèŒƒå›´: [{grid[:,:,:,1].min():.6f}, {grid[:,:,:,1].max():.6f}]")
        print(f"    ZèŒƒå›´: [{grid[:,:,:,2].min():.6f}, {grid[:,:,:,2].max():.6f}]")
        
        # æ£€æŸ¥æ•°æ®åˆ†å¸ƒå¯†åº¦
        center = grid[div1//2, div2//2, :, :]
        print(f"    ä¸­å¿ƒçº¿é•¿åº¦: {np.linalg.norm(center[-1] - center[0]):.6f}")
        print(f"    èµ·ç‚¹: {center[0]}")  
        print(f"    ç»ˆç‚¹: {center[-1]}")
        
        # æ£€æŸ¥æ˜¯å¦æœ‰é‡å¤ç‚¹æˆ–é›¶å¯†åº¦åŒºåŸŸ
        grid_flat = grid.reshape(-1, 3)
        unique_points = len(np.unique(grid_flat, axis=0))
        print(f"    å”¯ä¸€ç‚¹æ•°: {unique_points} / {len(grid_flat)}")
        
        # ç»˜åˆ¶æ‰€æœ‰å…‰æŸä¼ æ’­è·¯å¾„ï¼ˆå¯¹åº”MATLAB plot3(xls1,yls1,zls1,'.'))
        # å°†æ‰€æœ‰ç½‘æ ¼ç‚¹å±•å¹³ä¸ºä¸€ç»´æ•°ç»„ï¼Œæ¨¡æ‹ŸMATLABçš„reshapeé€»è¾‘
        grid_flat = grid.reshape(-1, 3)
        ax.plot(grid_flat[:, 0], grid_flat[:, 1], grid_flat[:, 2], 'b.', 
                alpha=0.6, markersize=1.5, label='Beam propagation path')
        
        # ç»˜åˆ¶ä¸­å¿ƒçº¿ï¼Œå¼ºè°ƒå¼¯æ›²ç‰¹å¾
        center = grid[div1//2, div2//2, :, :]
        ax.plot(center[:, 0], center[:, 1], center[:, 2], 'r-', linewidth=1, 
                alpha=0.9, label='Beam center')
        
        # ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆå¯¹åº”MATLAB plot3(B2(:,1),B2(:,2),B2(:,3),'o')ï¼‰
        start = beam_grid['beam_start'].cpu().numpy()
        end = beam_grid['beam_end'].cpu().numpy()
        # å°†èµ·ç‚¹ç»ˆç‚¹ç»„åˆæˆ2x3æ•°ç»„ï¼Œæ¨¡æ‹ŸMATLAB B2çš„æ ¼å¼
        B2_points = np.array([start, end])
        ax.plot(B2_points[:, 0], B2_points[:, 1], B2_points[:, 2], 'ro', 
                markersize=12, markerfacecolor='red', markeredgecolor='darkred', 
                markeredgewidth=2, label='Start/End points')
        
        # ç»˜åˆ¶ç®€åŒ–çš„æ‰˜å¡é©¬å…‹åœ†å½¢è¾¹ç•Œï¼ˆéªŒè¯å…‰æŸä½ç½®ï¼‰
        # ä¿®æ­£é—®é¢˜ï¼šä½¿ç”¨çœŸå®çš„ç­‰ç¦»å­ä½“è½´ä½ç½®
        print("  æç¤º: æ·»åŠ ç®€åŒ–çš„æ‰˜å¡é©¬å…‹è¾¹ç•Œè¿›è¡ŒéªŒè¯")
        
        # ä»å¹³è¡¡æ€æ•°æ®è·å–çœŸå®çš„ç­‰ç¦»å­ä½“è½´ä½ç½®
        if self.config is not None and hasattr(self.config, 'PA') and self.config.PA is not None:
            plasma_axis = self.config.PA.cpu().numpy()
            print(f"  ä½¿ç”¨çœŸå®çš„ç­‰ç¦»å­ä½“è½´ä½ç½®: PA = {plasma_axis}")
        else:
            # å¦‚æœæ²¡æœ‰é…ç½®æ•°æ®ï¼Œä½¿ç”¨ä¼°ç®—ä½ç½®
            plasma_axis = np.array([4.5, 0.0])  # ä¼°ç®—çš„ç­‰ç¦»å­ä½“è½´ä½ç½®
            print(f"  ä½¿ç”¨ä¼°ç®—çš„ç­‰ç¦»å­ä½“è½´ä½ç½®: PA = {plasma_axis}")
        
        # ä»ç­‰ç¦»å­ä½“è½´ä½ç½®æ¨ç®—æ‰˜å¡é©¬å…‹å‚æ•°
        # ä¿®æ­£ï¼šä½¿ç”¨çœŸå®çš„ç­‰ç¦»å­ä½“è½´ä½ç½®å’Œè¾¹ç•Œè®¡ç®—
        if self.config is not None and hasattr(self.config, 'PA') and self.config.PA is not None:
            plasma_axis = self.config.PA.cpu().numpy()
            R_major = plasma_axis[0]  # ä½¿ç”¨çœŸå®çš„ç­‰ç¦»å­ä½“è½´Råæ ‡ä½œä¸ºä¸»åŠå¾„
            # è®¡ç®—çœŸå®çš„å°åŠå¾„ï¼šä»GACè¾¹ç•Œæ•°æ®çš„æœ€å¤§å€¼ä¼°ç®—
            if hasattr(self.config, 'GAC') and self.config.GAC is not None:
                R_minor = self.config.GAC.max().item() * 0.8  # ç•¥å°äºæœ€å¤§è¾¹ç•Œå€¼
            else:
                R_minor = 2.0  # å¤‡ç”¨å€¼
        else:
            # å¦‚æœæ²¡æœ‰é…ç½®æ•°æ®ï¼Œä½¿ç”¨ç°æœ‰å€¼
            R_major = 4.5  
            R_minor = 2.0
        
        # ç”Ÿæˆæ›´å¤špoloidalæˆªé¢çš„åœ†å½¢è¾¹ç•Œï¼Œè®©è¾¹ç•Œæ›´å¯†é›†
        n_phi_sections = 20  # å¢åŠ æˆªé¢æ•°é‡ï¼ŒåŒ¹é…MATLABçš„å¯†é›†æ•ˆæœ
        phi_angles = np.linspace(0, 2*np.pi, n_phi_sections, endpoint=False)
        
        for i, phi in enumerate(phi_angles):
            # å½“å‰poloidalæˆªé¢çš„åœ†å¿ƒä½ç½®åŸºäºçœŸå®çš„ç­‰ç¦»å­ä½“è½´
            center_x = plasma_axis[0] + R_major * np.cos(phi)  # ä»¥ç­‰ç¦»å­ä½“è½´ä¸ºä¸­å¿ƒ
            center_y = plasma_axis[1] + R_major * np.sin(phi)
            center_z = 0  # å‡è®¾æ‰€æœ‰æˆªé¢åœ¨åŒä¸€Zé«˜åº¦
            
            # ç”Ÿæˆå½“å‰æˆªé¢çš„åœ†å½¢è¾¹ç•Œ
            n_boundary_points = 50
            theta = np.linspace(0, 2*np.pi, n_boundary_points, endpoint=True)
            x_boundary = center_x + R_minor * np.cos(theta) * np.cos(phi)
            y_boundary = center_y + R_minor * np.cos(theta) * np.sin(phi)
            z_boundary = center_z + R_minor * np.sin(theta)
            
            # ç»˜åˆ¶è¾¹ç•Œçº¿
            if i == 0:  # åªä¸ºç¬¬ä¸€ä¸ªæˆªé¢æ·»åŠ å›¾ä¾‹
                ax.plot(x_boundary, y_boundary, z_boundary, 'k-', 
                       linewidth=0.5, alpha=0.4, label='Simplified tokamak boundary')
            else:
                ax.plot(x_boundary, y_boundary, z_boundary, 'k-', 
                       linewidth=0.5, alpha=0.4)
        
        # æ·»åŠ ä¸€ä¸ªä¸»è¦çš„poloidalæˆªé¢ï¼ˆZ=0å¹³é¢ï¼‰
        # ä¿®æ­£ï¼šç¡®ä¿ä¸»æˆªé¢ä»¥çœŸå®çš„ç­‰ç¦»å­ä½“è½´ä¸ºä¸­å¿ƒ
        theta_main = np.linspace(0, 2*np.pi, 100, endpoint=True)
        x_main = plasma_axis[0] + (R_major + R_minor * np.cos(theta_main))  # ä»¥ç­‰ç¦»å­ä½“è½´ä¸ºä¸­å¿ƒ
        y_main = plasma_axis[1] + R_minor * np.sin(theta_main)
        z_main = np.zeros_like(x_main)  # Z=0å¹³é¢
        
        ax.plot(x_main, y_main, z_main, 'r--', 
               linewidth=3.0, alpha=0.9, label='Main poloidal cross-section (Z=0)')
        
        # æ·»åŠ toroidalæ–¹å‘çš„å‚è€ƒçº¿
        # åœ¨å‡ ä¸ªä¸åŒZé«˜åº¦çš„åœ†ç¯ï¼Œä»¥çœŸå®ç­‰ç¦»å­ä½“è½´ä¸ºä¸­å¿ƒ
        z_levels = [-1.5, -0.5, 0.5, 1.5]  # æ·»åŠ å¤šä¸ªZé«˜åº¦çš„åœ†ç¯
        colors = ['gray', 'lightgray', 'gray', 'lightgray']
        
        for i, z_level in enumerate(z_levels):
            n_torus_points = 100
            phi_torus = np.linspace(0, 2*np.pi, n_torus_points, endpoint=True)
            # ä»¥çœŸå®ç­‰ç¦»å­ä½“è½´ä¸ºä¸­å¿ƒçš„åœ†ç¯
            x_torus = plasma_axis[0] + (R_major + R_minor * 0.8 * np.cos(0)) * np.cos(phi_torus)
            y_torus = plasma_axis[1] + (R_major + R_minor * 0.8 * np.cos(0)) * np.sin(phi_torus)
            z_torus = np.full_like(x_torus, z_level)  # å›ºå®šZé«˜åº¦
            
            if i == 0:
                ax.plot(x_torus, y_torus, z_torus, color=colors[i], 
                       linewidth=1.0, alpha=0.6, linestyle=':', label='Toroidal rings')
            else:
                ax.plot(x_torus, y_torus, z_torus, color=colors[i], 
                       linewidth=1.0, alpha=0.6, linestyle=':')
        
        # æ·»åŠ ç­‰ç¦»å­ä½“è½´æ ‡è®°
        ax.scatter([plasma_axis[0]], [plasma_axis[1]], [0], 
                 c='red', s=100, marker='o', 
                 label=f'Plasma axis (PA = [{plasma_axis[0]:.3f}, {plasma_axis[1]:.3f}])')
        
        print(f"  ç”Ÿæˆäº† {n_phi_sections} ä¸ªpoloidalæˆªé¢å’Œ {len(z_levels)} ä¸ªtoroidalåœ†ç¯")
        print(f"  ç­‰ç¦»å­ä½“è½´ä½ç½®: PA = [{plasma_axis[0]:.6f}, {plasma_axis[1]:.6f}]")
        
        # æ ‡å‡†åŒ–åæ ‡è½´æ ‡ç­¾ï¼ˆä¸¥æ ¼æŒ‰ç…§MATLABçš„X, Y, Zæ ¼å¼ï¼‰
        ax.set_xlabel('X', fontsize=12, fontweight='bold')
        ax.set_ylabel('Y', fontsize=12, fontweight='bold') 
        ax.set_zlabel('Z', fontsize=12, fontweight='bold')
        ax.legend(loc='upper right', fontsize=10)
        ax.set_title('3D Beam Geometry - Complex Tokamak Configuration (Figure 1)', 
                     fontsize=14, fontweight='bold')
        
        # æ”¹å–„3Dè§†è§’
        ax.view_init(elev=20, azim=45)  # è°ƒæ•´è§†è§’ä»¥æ›´å¥½åœ°æ˜¾ç¤º3Dç»“æ„
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Figure saved: {save_path}")
        else:
            plt.show()
        plt.close()
    
    def plot_detector_contour(Figure 3: æ£€æµ‹å™¨ä¿¡å·ç­‰é«˜çº¿å›¾

        self,
        pci_image: torch.Tensor,
        beam_config,
        time_t: float,
        save_path: Optional[str] = None
    ):
        """æ£€æµ‹å™¨ä¿¡å·ç­‰é«˜çº¿å›¾ï¼ˆä¸¥æ ¼å¯¹åº”MATLAB Figure 3ï¼‰
        
        Args:
            pci_image: PCIä¿¡å·å›¾åƒ
            beam_config: å…‰æŸé…ç½®ï¼ŒåŒ…å«width_v, width_t, n_detectors_v, n_detectors_t
            time_t: æ—¶é—´ç‚¹
            save_path: ä¿å­˜è·¯å¾„
        """
        # MATLABä¸­çš„å‚æ•°æå–
        wid1 = beam_config.width_vertical  # å‚ç›´å®½åº¦
        wid2 = beam_config.width_toroidal  # ç¯å‘å®½åº¦
        div1 = beam_config.div_vertical    # å‚ç›´åŠèŒƒå›´
        div2 = beam_config.div_toroidal    # ç¯å‘åŠèŒƒå›´
        
        # ä¸¥æ ¼æŒ‰ç…§MATLAB: [xx1,yy1]=meshgrid(wid1/2*[-div1:div1]/div1,-wid2/2*[-div2:div2]/div2)
        # æ³¨æ„ï¼šdiv1å’Œdiv2å·²ç»æ˜¯åŠèŒƒå›´ï¼Œæ‰€ä»¥[-div1:div1]ä¼šç»™å‡º2*div1+1ä¸ªç‚¹
        xx1 = np.meshgrid(
            wid1/2 * np.arange(-div1, div1+1) / div1,
            -wid2/2 * np.arange(-div2, div2+1) / div2
        )[0]
        
        yy1 = np.meshgrid(
            wid1/2 * np.arange(-div1, div1+1) / div1,
            -wid2/2 * np.arange(-div2, div2+1) / div2
        )[1]
        
        # MATLAB: xx1 = fliplr(xx1) - æ°´å¹³ç¿»è½¬
        xx1 = np.fliplr(xx1).copy()  # ä½¿ç”¨.copy()é¿å…è´Ÿæ­¥é•¿é—®é¢˜
        
        pci_np = pci_image.cpu().numpy()
        
        # å¤„ç†3Dæ•°æ®ï¼šæ²¿å…‰æŸè·¯å¾„ç§¯åˆ†å¾—åˆ°2Dæ£€æµ‹å™¨ä¿¡å·
        if pci_np.ndim == 3:
            # æŒ‰ç…§MATLABé€»è¾‘ï¼špout2 = sum(pout1, 3)
            pci_2d = np.sum(pci_np, axis=2)
        else:
            pci_2d = pci_np
        
        fig = plt.figure(figsize=(10, 8))
        
        # ä¸¥æ ¼æŒ‰ç…§MATLAB: contourf(yy1.',xx1.',pout2,100,'LineStyle','none')
        plt.contourf(yy1.T, xx1.T, pci_2d, levels=100)
        
        # MATLAB: shading flat
        plt.gca().set_facecolor('white')
        
        # MATLAB: axis equal
        plt.axis('equal')
        
        # MATLAB: colorbar
        cbar = plt.colorbar()
        
        # MATLAB: xlabel('x (m)'); ylabel('y (m)')
        plt.xlabel('x (m)')
        plt.ylabel('y (m)')
        
        # æ·»åŠ æ—¶é—´ä¿¡æ¯
        plt.title(f'Detector Signal (t = {time_t:.2f}) (Figure 3)')
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Figure saved: {save_path}")
        else:
            plt.show()
        plt.close()
    
    def plot_wavenumber_contour(
        self,
        Amp: torch.Tensor,
        KX: torch.Tensor,
        KY: torch.Tensor,
        mode_name: str,
        save_path: Optional[str] = None
    ):
        """æ³¢æ•°ç©ºé—´ç­‰é«˜çº¿å›¾ï¼ˆå¯¹åº”MATLAB Figure 4ï¼‰"""
        fig = plt.figure(figsize=(10, 8))
        
        Amp_np = Amp.cpu().numpy()
        KX_np = KX.cpu().numpy()
        KY_np = KY.cpu().numpy()
        
        plt.contourf(KX_np, KY_np, np.log(Amp_np + 1e-10), 100, cmap='viridis')
        plt.xlabel(r'$k_x\rho_i$')
        plt.ylabel(r'$k_y\rho_i$')
        plt.colorbar(label='log(Amplitude)')
        plt.title(f'{mode_name} (Figure 4)')
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Figure saved: {save_path}")
        else:
            plt.show()
        plt.close()
    
    def plot_time_evolution_animation(
        self,
        pout2_series: torch.Tensor,
        xx: torch.Tensor,
        yy: torch.Tensor,
        times: torch.Tensor,
        save_path: str
    ):
        """æ—¶é—´æ¼”åŒ–åŠ¨ç”»"""
        try:
            import matplotlib.animation as animation
        except ImportError:
            print("matplotlib.animation required for animation")
            return
        
        fig = plt.figure(figsize=(10, 8))
        
        pout2_np = pout2_series.cpu().numpy()
        xx_np = xx.cpu().numpy()
        yy_np = yy.cpu().numpy()
        times_np = times.cpu().numpy()
        
        # è®¡ç®—å…¨å±€vmin/vmax
        vmin, vmax = pout2_np.min(), pout2_np.max()
        
        def update(frame):
            plt.clf()
            plt.contourf(yy_np, xx_np, pout2_np[:, :, frame], 100, cmap='RdBu_r', vmin=vmin, vmax=vmax)
            plt.axis('equal')
            plt.colorbar(label='Signal')
            plt.xlabel('x (m)')
            plt.ylabel('y (m)')
            plt.title(f't = {times_np[frame]:.2f}')
        
        anim = animation.FuncAnimation(fig, update, frames=pout2_np.shape[2], interval=100)
        anim.save(save_path, writer='pillow', fps=10)
        print(f"Animation saved: {save_path}")
        plt.close()
    
    def plot_density_slice(
        self,
        density_3d: torch.Tensor,
        config: GENEConfig,
        beam_config=None,
        slice_indices: Optional[list] = None,
        save_path: Optional[str] = None
    ):
        """å¯†åº¦åœºpoloidalæˆªé¢å¯è§†åŒ– (ä¿®æ­£ä¸ºMATLABé€»è¾‘)
        
        Args:
            density_3d: 3Då¯†åº¦åœºæ•°æ® [R, Z, phi]
            config: GENEé…ç½®ï¼ŒåŒ…å«GRC, GZCåæ ‡ç½‘æ ¼
            beam_config: å…‰æŸé…ç½® (ä¿æŒå…¼å®¹æ€§)
            slice_indices: ä¿ç•™å‚æ•°å…¼å®¹æ€§ï¼Œä½†ä½¿ç”¨poloidalæˆªé¢
            save_path: ä¿å­˜è·¯å¾„
        """
        if config.GRC is None or config.GZC is None:
            print("  Error: GRC/GZC coordinate grid data not available")
            return
            
        # æŒ‰ç…§MATLAB cont_data2_s.mçš„é€»è¾‘å®ç°poloidalæˆªé¢å¯è§†åŒ–
        # è·å–åæ ‡ç½‘æ ¼ (MATLAB: contourf(obj.GRC,obj.GZC,(2*z),30,'LineStyle','none'))
        grc = config.GRC.cpu().numpy()  # Råæ ‡ç½‘æ ¼
        gzc = config.GZC.cpu().numpy()  # Zåæ ‡ç½‘æ ¼
        
        # å¤„ç†å¯†åº¦æ•°æ® (MATLAB: z=real(data2)*cos_pha-imag(data2)*sin_pha)
        density_np = density_3d.cpu().numpy()
        
        # å¦‚æœæ˜¯3Dæ•°æ®ï¼Œå–ä¸­é—´phiæˆªé¢ä½œä¸ºpoloidalæˆªé¢ (MATLABæ–¹å¼)
        if density_np.ndim == 3:
            phi_idx = density_np.shape[2] // 2
            density_2d = density_np[:, :, phi_idx]
            # ä¿®æ­£ç»´åº¦ä¸åŒ¹é…ï¼šå¯†åº¦æ•°æ® (R, Z) -> (Z, R) ä»¥åŒ¹é…MATLABåæ ‡ç½‘æ ¼
            density_2d = density_2d.T  # è½¬ç½®ä»¥åŒ¹é… (129, 401) çš„åæ ‡ç½‘æ ¼
        else:
            density_2d = density_np
            
        # å¤„ç†å¤æ•°æ•°æ® (if exists)
        if density_2d.dtype == np.complex64 or density_2d.dtype == np.complex128:
            # MATLAB: z=real(data2)*cos_pha-imag(data2)*sin_pha
            density_processed = np.real(density_2d) * 2  # MATLAB *2 factor
        else:
            density_processed = density_2d * 2  # MATLAB *2 factor
        
        # Ensure data dimension matching
        if density_processed.shape != grc.shape:
            print(f"  Warning: Data dimension mismatch {density_processed.shape} vs {grc.shape}")
            min_rows = min(density_processed.shape[0], grc.shape[0])
            min_cols = min(density_processed.shape[1], grc.shape[1])
            density_processed = density_processed[:min_rows, :min_cols]
            grc = grc[:min_rows, :min_cols]
            gzc = gzc[:min_rows, :min_cols]
        
        # åˆ›å»ºpoloidalæˆªé¢å›¾ (MATLAB: contourf(obj.GRC,obj.GZC,(2*z),30,'LineStyle','none'))
        fig = plt.figure(figsize=(12, 8))
        plt.contourf(grc, gzc, density_processed, levels=30, cmap='RdBu_r')
        plt.gca().set_aspect('equal')  # MATLAB: axis equal
        plt.xlabel('R (m)')
        plt.ylabel('Z (m)')
        plt.title(f'Density Poloidal Cross-Section (phi={phi_idx}) (Figure 2)')
        plt.colorbar(label='Density')
        
        # MATLAB: shading flat
        plt.gca().set_facecolor('white')
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Figure saved: {save_path}")
        else:
            plt.show()
        plt.close()
        
        return phi_idx  # è¿”å›ä½¿ç”¨çš„phiæˆªé¢ç´¢å¼•
    
    def plot_density_3d_orthogonal(
        self,
        density_3d: torch.Tensor,
        config: GENEConfig,
        center_indices: Optional[dict] = None,
        save_path: Optional[str] = None
    ):
        """3Då¯†åº¦åœºçš„æ­£äº¤åˆ‡ç‰‡å¯è§†åŒ–
        
        Args:
            density_3d: 3Då¯†åº¦åœºæ•°æ® [R, Z, phi]
            config: GENEé…ç½®
            center_indices: ä¸­å¿ƒåˆ‡ç‰‡ç´¢å¼• {'r': R//2, 'z': Z//2, 'phi': phi//2}
            save_path: ä¿å­˜è·¯å¾„
        """
        if center_indices is None:
            center_indices = {
                'r': density_3d.shape[0] // 2,
                'z': density_3d.shape[1] // 2,
                'phi': density_3d.shape[2] // 2
            }
        
        density_np = density_3d.cpu().numpy()
        
        # åˆ›å»º2x2å­å›¾
        fig, axes = plt.subplots(2, 2, figsize=(12, 10))
        
        # R-Zå¹³é¢ï¼ˆpoloidalæˆªé¢ï¼Œphiå›ºå®šï¼‰
        rz_slice = density_np[:, :, center_indices['phi']]
        im1 = axes[0, 0].contourf(rz_slice, levels=100, cmap='RdBu_r')
        axes[0, 0].set_title(f'R-Zæˆªé¢ (Ï†={center_indices["phi"]})')
        axes[0, 0].set_xlabel('R index')
        axes[0, 0].set_ylabel('Z index')
        plt.colorbar(im1, ax=axes[0, 0])
        
        # R-Ï†å¹³é¢ï¼ˆtoroidalæˆªé¢ï¼ŒZå›ºå®šï¼‰
        rphi_slice = density_np[:, center_indices['z'], :]
        im2 = axes[0, 1].contourf(rphi_slice.T, levels=100, cmap='RdBu_r')
        axes[0, 1].set_title(f'R-Ï†æˆªé¢ (Z={center_indices["z"]})')
        axes[0, 1].set_xlabel('Ï† index')
        axes[0, 1].set_ylabel('R index')
        plt.colorbar(im2, ax=axes[0, 1])
        
        # Z-Ï†å¹³é¢ï¼ˆpoloidalæˆªé¢ï¼ŒRå›ºå®šï¼‰
        zphi_slice = density_np[center_indices['r'], :, :]
        im3 = axes[1, 0].contourf(zphi_slice.T, levels=100, cmap='RdBu_r')
        axes[1, 0].set_title(f'Z-Ï†æˆªé¢ (R={center_indices["r"]})')
        axes[1, 0].set_xlabel('Ï† index')
        axes[1, 0].set_ylabel('Z index')
        plt.colorbar(im3, ax=axes[1, 0])
        
        # 3Då¯†åº¦åˆ†å¸ƒç›´æ–¹å›¾
        axes[1, 1].hist(density_np.flatten(), bins=50, alpha=0.7, color='skyblue')
        axes[1, 1].set_title('å¯†åº¦åˆ†å¸ƒç›´æ–¹å›¾')
        axes[1, 1].set_xlabel('å¯†åº¦å€¼')
        axes[1, 1].set_ylabel('é¢‘æ¬¡')
        axes[1, 1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Figure saved: {save_path}")
        else:
            plt.show()
        plt.close()

    def plot_mode_structure(
        self,
        R: torch.Tensor,
        p2: torch.Tensor,
        m: int,
        n: int,
        save_path: Optional[str] = None
    ):
        """
        æ¨¡å¼ç»“æ„å›¾ï¼ˆä¸¥æ ¼å¯¹åº”MATLAB plot_mode_structure.mï¼‰
        
        Args:
            R: å¾„å‘åæ ‡æ•°ç»„
            p2: æ¨¡æ€æ•°æ® [radial_points, 6ä¸ªç‰©ç†é‡] (PHI, PSI, VPL, NE, TE, TI)
            m, n: æ¨¡æ€ç¼–å·
            save_path: ä¿å­˜è·¯å¾„
        """
        # ç‰©ç†é‡åç§°å’Œå¯¹åº”å…³ç³» (ä¸¥æ ¼æŒ‰ç…§MATLAB)
        # MATLAB: PHI(321), PSI(322), VPL(324), NE(323), TE(325), TI(326)
        subplot_mappings = [
            ('PHI', 3, 2, 1),   # subplot(321)
            ('PSI', 3, 2, 2),   # subplot(322)
            ('VPL', 3, 2, 4),   # subplot(324) 
            ('NE',  3, 2, 3),   # subplot(323)
            ('TE',  3, 2, 5),   # subplot(325)
            ('TI',  3, 2, 6),   # subplot(326)
        ]
        
        # è½¬æ¢ä¸ºnumpyæ•°ç»„ä»¥ä¾¿å¤„ç†
        R_np = R.cpu().numpy()
        
        # ä½¿ç”¨ä¸MATLABç›¸è¿‘çš„å›¾åƒå¤§å° (é»˜è®¤matplotlib figsizeçº¦6.4x4.8)
        fig = plt.figure(figsize=(10, 8))
        
        for i, (field_name, rows, cols, index) in enumerate(subplot_mappings):
            ax = fig.add_subplot(rows, cols, index)
            
            # è·å–å¯¹åº”ç‰©ç†é‡çš„æ•°æ®
            field_data = p2[:, i].cpu().numpy()
            
            # MATLAB: plot(obj.R,real(p2(:,a)),'r',obj.R,imag(p2(:,a)),'b')
            # ä½¿ç”¨é»˜è®¤çº¿å®½ï¼Œä¸MATLABä¸€è‡´
            ax.plot(R_np, np.real(field_data), 'r-', label='Real')
            ax.plot(R_np, np.imag(field_data), 'b-', label='Imag')
            
            # è®¾ç½®æ ‡é¢˜å’Œæ ‡ç­¾ï¼ˆä¸¥æ ¼æŒ‰ç…§MATLABï¼‰
            ax.set_title(field_name)
            ax.set_xlabel('r')
            
            # MATLAB: axis tight
            ax.autoscale(axis='both', tight=True)
            
            # MATLAB: legend('Real','Imag','Location','Best') - åªå¯¹PHIå’ŒPSI
            if field_name in ['PHI', 'PSI']:
                ax.legend(['Real', 'Imag'], loc='best', fontsize=8)
        
        # æ·»åŠ æ€»æ ‡é¢˜
        fig.suptitle(f'Mode Structure (m={m}, n={n})', fontsize=14, fontweight='bold')
        
        # è°ƒæ•´å­å›¾é—´è·
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Mode structure saved: {save_path}")
        else:
            plt.show()
        plt.close()

    def plot_mode_structure_complete(
        self,
        R: torch.Tensor,
        p2_all: torch.Tensor,
        m_values: list,
        n_values: list,
        save_path: Optional[str] = None
    ):
        """
        å®Œæ•´çš„æ¨¡å¼ç»“æ„å›¾æ˜¾ç¤ºï¼ˆæ”¯æŒå¤šæ¨¡æ€ï¼‰
        
        Args:
            R: å¾„å‘åæ ‡æ•°ç»„
            p2_all: æ‰€æœ‰æ¨¡æ€æ•°æ® [n_modes, radial_points, 6ä¸ªç‰©ç†é‡]
            m_values: mæ¨¡æ€ç¼–å·åˆ—è¡¨
            n_values: næ¨¡æ€ç¼–å·åˆ—è¡¨
            save_path: ä¿å­˜è·¯å¾„
        """
        n_modes = len(m_values)
        
        # è®¡ç®—å­å›¾å¸ƒå±€
        n_cols = min(3, n_modes)  # æœ€å¤š3åˆ—
        n_rows = (n_modes + n_cols - 1) // n_cols
        
        fig, axes = plt.subplots(n_rows, n_cols, figsize=(5*n_cols, 4*n_rows))
        
        # ç¡®ä¿axesæ˜¯2Dæ•°ç»„
        if n_rows == 1 and n_cols == 1:
            axes = [[axes]]
        elif n_rows == 1 or n_cols == 1:
            axes = axes.reshape(n_rows, n_cols)
        
        R_np = R.cpu().numpy()
        field_names = ['PHI', 'PSI', 'VPL', 'NE', 'TE', 'TI']
        
        for mode_idx, (m, n) in enumerate(zip(m_values, n_values)):
            row = mode_idx // n_cols
            col = mode_idx % n_cols
            ax = axes[row, col]
            
            # è·å–æ¨¡æ€æ•°æ®
            p2 = p2_all[mode_idx]
            
            # é€‰æ‹©ç¬¬ä¸€ä¸ªç‰©ç†é‡ï¼ˆPHIï¼‰ä½œä¸ºç¤ºä¾‹
            phi_data = p2[:, 0].cpu().numpy()
            ax.plot(R_np, np.real(phi_data), 'r-', linewidth=1, label='Real')
            ax.plot(R_np, np.imag(phi_data), 'b-', linewidth=1, label='Imag')
            
            ax.set_title(f'm={m}, n={n}')
            ax.set_xlabel('r')
            ax.legend(fontsize=8)
            ax.grid(True, alpha=0.3)
        
        # éšè—å¤šä½™çš„å­å›¾
        for mode_idx in range(n_modes, n_rows * n_cols):
            row = mode_idx // n_cols
            col = mode_idx % n_cols
            if row < n_rows and col < n_cols:
                axes[row, col].set_visible(False)
        
        plt.tight_layout()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Complete mode structure saved: {save_path}")
        else:
            plt.show()
        plt.close()

    def plot_spectrum(
        self,
        p2: torch.Tensor,
        field_number: int = 4,
        save_path: Optional[str] = None
    ):
        """
        ç»˜åˆ¶èƒ½è°±å›¾ï¼ˆä¸¥æ ¼å¯¹åº”MATLAB plot_spectrum.mï¼‰
        
        Args:
            p2: å…¨æ¨¡æ€æ•°æ® [radial_points, poloidal_modes, toroidal_modes, n_fields]
            field_number: ç‰©ç†é‡ç¼–å· (4=DENS, 5=TEME, å…¶ä»–=1.0)
            save_path: ä¿å­˜è·¯å¾„
        """
        # ç‰©ç†é‡ç³»æ•°ï¼ˆä¸¥æ ¼æŒ‰ç…§MATLABï¼‰
        # å‡è®¾åˆç†çš„BETAIå’ŒBETAEå€¼
        betai = getattr(self.config, 'BETAI', None)
        betae = getattr(self.config, 'BETAE', None)
        
        if betai is None or betae is None:
            # å¦‚æœæ²¡æœ‰è®¾ç½®BETAIå’ŒBETAEï¼Œä½¿ç”¨betaå‚æ•°ä¼°ç®—
            beta = getattr(self.config, 'beta', 0.01)
            betai = beta * 0.8 if beta > 0 else 0.01
            betae = beta * 0.2 if beta > 0 else 0.01
        
        if field_number == 4:  # DENS
            coef = 1.0 / (betai + betae)
        elif field_number == 5:  # TEME
            coef = 1.5 / betai
        else:  # å…¶ä»–ç‰©ç†é‡
            coef = 1.0
        
        # è½¬æ¢ä¸ºnumpyå¤„ç†
        p2_np = p2.cpu().numpy()
        
        # MATLAB: dr=zeros(obj.IRMAX+1,1);
        #         dr(1:end-1)=obj.R(2:end)-obj.R(1:end-1);
        R_np = self.config.R.cpu().numpy()
        dr = np.zeros(len(R_np))
        dr[0:-1] = R_np[1:] - R_np[0:-1]
        
        # MATLAB: ss=squeeze(sum(p2(:,:,:,fn).*conj(p2(:,:,:,fn)).*repmat(obj.R.*dr,1,obj.LYM2,obj.LZM2),1));
        # é€‰æ‹©ç‰¹å®šç‰©ç†é‡
        fn_idx = field_number - 1  # MATLABæ˜¯1åŸºç´¢å¼•ï¼ŒPythonæ˜¯0åŸºç´¢å¼•
        p2_field = p2_np[:, :, :, fn_idx]  # [radial, poloidal, toroidal]
        
        # è®¡ç®—æ¨¡æ–¹å¹¶ä¹˜ä»¥å¾„å‘æƒé‡
        p2_conj = np.conj(p2_field)
        energy_density = p2_field * p2_conj
        
        # MATLAB: repmat(obj.R.*dr,1,obj.LYM2,obj.LZM2)
        R_dr = R_np * dr  # [radial_points]
        weight_3d = np.broadcast_to(R_dr[:, np.newaxis, np.newaxis], 
                                   (len(R_dr), p2_field.shape[1], p2_field.shape[2]))
        
        # åº”ç”¨æƒé‡å¹¶å¯¹å¾„å‘ç§¯åˆ†
        weighted_energy = energy_density * weight_3d
        ss = np.sum(weighted_energy, axis=0)  # æ²¿å¾„å‘æ±‚å’Œ
        
        # ==============================================================================
        # ä¸¥æ ¼æŒ‰ç…§MATLABçš„æ¨¡æ€é‡æ’é€»è¾‘
        # ==============================================================================
        
        # MATLAB: ss2=zeros(obj.LYM2,obj.LZM2);
        LYM2 = p2_field.shape[1]  # æ€»poloidalæ¨¡æ€æ•°
        LZM2 = p2_field.shape[2]  # æ€»toroidalæ¨¡æ€æ•°
        ss2 = np.zeros((LYM2, LZM2), dtype=ss.dtype)
        
        # MATLAB: KYM = KYMt/2 (æ­£mæ¨¡æ€æ•°)
        # LYM2 = KYMt (æ€»æ¨¡æ€æ•°ï¼ŒåŒ…å«æ­£è´Ÿå’Œé›¶æ¨¡æ€)
        # æ‰€ä»¥: KYM = LYM2//2
        KYM = LYM2 // 2  # æ­£mæ¨¡æ€æ•°
        KZM = LZM2 - 1   # toroidalæ¨¡æ€æœ€å¤§ç¼–å·
        
        # MATLAB: ss2(KYM:end,:)=ss(1:KYM+1,:);        % æ­£mæ¨¡æ€: 0åˆ°KYM
        # æ­£mæ¨¡æ€æ•°: KYM+1ä¸ª (0, 1, 2, ..., KYM)
        # ä½ç½®: KYM åˆ° LYM2-1 (ä»KYMå¼€å§‹å¡«å……)
        pos_m_length = min(KYM + 1, ss.shape[0], LYM2 - KYM)
        if pos_m_length > 0:
            ss2[KYM:KYM+pos_m_length, :] = ss[0:pos_m_length, :]
        
        # MATLAB: ss2(1:KYM-1,:)=ss(KYM+2:end,:);      % è´Ÿmæ¨¡æ€: -(KYM-1)åˆ°-1
        # è´Ÿmæ¨¡æ€æ•°: KYM-1ä¸ª (-(KYM-1), ..., -2, -1)
        # ä½ç½®: 0 åˆ° KYM-2 (ä»å‰KYM-1ä¸ªä½ç½®å¼€å§‹å¡«å……)
        neg_m_target = KYM - 1
        neg_m_source_start = KYM + 2
        neg_m_source_length = ss.shape[0] - neg_m_source_start
        neg_m_copy_length = min(neg_m_target, neg_m_source_length, LYM2)
        
        if neg_m_copy_length > 0:
            ss2[0:neg_m_copy_length, :] = ss[neg_m_source_start:neg_m_source_start+neg_m_copy_length, :]
        
        # MATLAB: ss2(1:KYM-1,1)=ss([KYM:-1:2],1);   % toroidalæ¨¡æ€0çš„è´Ÿméƒ¨åˆ†
        # ç‰¹æ®Šå¤„ç†ï¼štoroidalæ¨¡æ€0 (ç¬¬ä¸€ä¸ªåˆ—) çš„è´Ÿméƒ¨åˆ†éœ€è¦åå‘å¡«å……
        if LZM2 > 0 and KYM > 1:
            special_length = min(KYM - 1, ss.shape[0])
            if special_length > 0:
                # åå‘ç´¢å¼•ï¼šss[KYM-1], ss[KYM-2], ..., ss[2]
                reverse_indices = list(range(min(KYM, ss.shape[0]) - 1, max(0, KYM - special_length - 1), -1))
                copy_length = min(len(reverse_indices), KYM - 1, ss2.shape[0])
                if copy_length > 0:
                    ss2[0:copy_length, 0] = ss[reverse_indices[:copy_length], 0]
        
        # ==============================================================================
        # æ¨¡æ€é‡æ’å®Œæˆ
        # ==============================================================================
        
        # åº”ç”¨ç³»æ•°å¹¶ç¡®ä¿å®æ•°
        ss2 = np.abs(ss2 * coef)  # ä½¿ç”¨ç»å¯¹å€¼ç¡®ä¿å®æ•°
        
        # MATLAB: [x,y]=meshgrid([-obj.KYM+1:obj.KYM],[0:obj.KZM]);
        #         contourf(x,y,log10(ss2.'),30,'LineStyle','none');
        
        # è®¡ç®—æ­£ç¡®çš„m,nèŒƒå›´ï¼ˆä¸¥æ ¼æŒ‰ç…§MATLABï¼‰
        # mèŒƒå›´: [-KYM, ..., -1, 0, 1, ..., KYM]  å…±2*KYM+1ä¸ªå€¼
        # nèŒƒå›´: [0, 1, ..., KZM]  å…±KZM+1ä¸ªå€¼
        m_range = np.arange(-KYM, KYM + 1)  # ä»-KYMåˆ°KYMï¼Œå…±2*KYM+1ä¸ªå€¼
        n_range = np.arange(0, KZM + 1)     # æ­£å¥½æ˜¯0åˆ°KZM
        
        # ç”Ÿæˆç½‘æ ¼ï¼ˆMATLAB meshgridè¡Œä¸ºï¼‰
        X, Y = np.meshgrid(m_range, n_range, indexing='xy')  # åŒ¹é…MATLABçš„meshgridè¡Œä¸º
        
        # ç¡®ä¿æ•°æ®ç»´åº¦ä¸ç½‘æ ¼åŒ¹é…
        if ss2.shape != X.shape:
            # æ³¨æ„ï¼šss2æ˜¯(21,5)ï¼ŒXæ˜¯(5,21)ï¼Œè¿™æ˜¯æ­£ç¡®çš„
            # MATLABä¸­ss2.'å°±æ˜¯è½¬ç½®ï¼Œæ‰€ä»¥ä¸éœ€è¦è°ƒæ•´åŸå§‹ss2
            pass  # ä¿æŒåŸæ ·ï¼Œè®©è½¬ç½®æ¥å¤„ç†ç»´åº¦åŒ¹é…
        
        # ç»˜åˆ¶å›¾å½¢
        fig = plt.figure(figsize=(10, 8))
        
        # ç»˜åˆ¶30å±‚å¯¹æ•°ç­‰é«˜çº¿
        try:
            # MATLAB: contourf(x,y,log10(ss2.'),30,'LineStyle','none');
            # MATLABä½¿ç”¨ss2.'å³è½¬ç½®ï¼Œä½†éœ€è¦æ³¨æ„ç»´åº¦åŒ¹é…
            # X: (21,5), Y: (21,5), ss2: (21,5)
            # è½¬ç½®åss2.T: (5,21)ï¼Œä¸Xçš„è½¬ç½®å½¢çŠ¶åŒ¹é…
            contour = plt.contourf(X, Y, np.log10(ss2.T + 1e-10), levels=30)
            
            # MATLAB: shading flat;
            plt.gca().set_facecolor('white')
            
            # è®¾ç½®æ ‡ç­¾å’Œæ ‡é¢˜
            plt.title('spectrum')
            plt.xlabel('m')
            plt.ylabel('n')
            plt.axis('tight')
            
            # æ·»åŠ é¢œè‰²æ¡
            cbar = plt.colorbar()
            cbar.set_label('log10(Amplitude)')
            
        except Exception as e:
            print(f"    Contour plotting warning: {e}")
            # Fallback: ensure dimensions are correct
            print(f"    Trying adjustment: X{X.shape}, Y{Y.shape}, ss2{ss2.shape}")
            # X(5, 21), Y(5, 21), ss2 should be (21, 5), after transpose (5, 21)
            data_for_plot = ss2.T  # MATLAB's ss2.' is transpose
            
            try:
                plt.contourf(X, Y, np.log10(data_for_plot + 1e-10), levels=30)
                plt.gca().set_facecolor('white')
                plt.title('spectrum (fallback)')
                plt.xlabel('m')
                plt.ylabel('n')
                plt.colorbar()
            except Exception as e2:
                print(f"    Fallback method also failed: {e2}")
                # Final fallback
                plt.imshow(np.log10(ss2 + 1e-10), aspect='auto', origin='lower',
                          extent=[m_range[0], m_range[-1], n_range[0], n_range[-1]])
                plt.colorbar()
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"  Spectrum saved: {save_path}")
        else:
            plt.show()
        plt.close()
    
    def spectrum(
        self,
        sim_type: str,
        data_n: int,
        t: float,
        save_path: Optional[str] = None
    ):
        """
        ä¸»èƒ½è°±åˆ†æå‡½æ•°ï¼ˆå¯¹åº”MATLAB spectrum.mï¼‰
        
        Args:
            sim_type: ä»¿çœŸç±»å‹ ('R6F', 'r6f', 'R5F', 'r5f')
            data_n: æ•°æ®ç¼–å·
            t: æ—¶é—´ç‚¹
            save_path: ä¿å­˜è·¯å¾„
        """
        # è¿™é‡Œéœ€è¦å®ç°æ•°æ®è¯»å–é€»è¾‘
        # æš‚æ—¶ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®è¿›è¡Œæ¼”ç¤º
        print(f"èƒ½è°±åˆ†æ: sim_type={sim_type}, data_n={data_n}, t={t}")
        
        # ä¸¥æ ¼æŒ‰ç…§MATLABçš„æ¨¡æ€å®šä¹‰åˆ›å»ºæ•°æ®
        # å‡è®¾KYM=10, KZM=4, åˆ™LYM2=2*KYM+1=21, LZM2=KZM+1=5
        KYM = 10  # æ­£mæ¨¡æ€æ•°
        KZM = 4   # toroidalæ¨¡æ€æœ€å¤§ç¼–å·
        
        n_radial = len(self.config.R)  # ä½¿ç”¨configä¸­çš„å¾„å‘ç‚¹æ•°ï¼Œç¡®ä¿ä¸plot_spectrumä¸€è‡´
        n_poloidal = 2 * KYM + 1  # æ€»æ¨¡æ€æ•° = æ­£m+è´Ÿm+é›¶æ¨¡æ€ = 21
        n_toroidal = KZM + 1      # toroidalæ¨¡æ€æ•° = KZM+1 = 5
        n_fields = 6
        
        print(f"  æ¨¡æ€é…ç½®: KYM={KYM}, KZM={KZM}, LYM2={n_poloidal}, LZM2={n_toroidal}")
        
        p2 = torch.zeros((n_radial, n_poloidal, n_toroidal, n_fields), 
                        dtype=torch.complex64, device='hip')
        
        # ç”Ÿæˆä¸€äº›æ¨¡æ‹Ÿçš„æ¨¡æ€æ•°æ®
        for i in range(n_fields):
            for j in range(n_poloidal):
                for k in range(n_toroidal):
                    # åˆ›å»ºä¸€äº›æ¨¡å¼ç»“æ„
                    r = torch.linspace(0.1, 2.0, n_radial)
                    real_part = torch.sin(2 * np.pi * r * (1 + 0.1 * (j + k)))
                    imag_part = torch.cos(2 * np.pi * r * (1 + 0.1 * (j + k)))
                    p2[:, j, k, i] = real_part + 1j * imag_part
        
        # æ ¹æ®æ—¶é—´é€‰æ‹©ç‰©ç†é‡
        if t == 0:
            # æ—¶é—´åºåˆ—ï¼Œä½¿ç”¨DENS (field 4)
            field_number = 4
        else:
            # å•æ—¶é—´ç‚¹ï¼Œä½¿ç”¨TEME (field 5)
            field_number = 5
        
        print(f"  Using field: {field_number} ({'DENS' if field_number == 4 else 'TEME' if field_number == 5 else 'OTHER'})")
        
        # ç»˜åˆ¶èƒ½è°±å›¾
        self.plot_spectrum(p2, field_number, save_path)
        
        return p2


def plot_wavenumber_space_2d(Figure 4: 2Dæ³¢æ•°ç©ºé—´å›¾

    xx,
    yy,
    real_space_data: torch.Tensor,
    config: GENEConfig,
    save_path: Optional[str] = None
) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:
    """
    2Dæ³¢æ•°ç©ºé—´åˆ†æï¼ˆä¸¥æ ¼æŒ‰ç…§MATLAB plotWaveNumberSpace.mï¼‰
    """
    # MATLAB: Mean = mean(mean(realSpaceData(:)));
    Mean = torch.mean(real_space_data)
    
    # MATLAB: realSpaceData = realSpaceData - Mean;
    data_centered = real_space_data - Mean
    
    # MATLAB: [Ny, Nx] = size(realSpaceData);
    # å¤„ç†3Dæ•°æ®ï¼šå–2DæŠ•å½±
    if data_centered.ndim == 3:
        # æŒ‰ç…§MATLABé€»è¾‘ï¼špout2 = sum(pout1, 3)
        data_2d = torch.sum(data_centered, dim=2)
    else:
        data_2d = data_centered
    
    Ny, Nx = data_2d.shape
    
    # MATLAB: P = fft2(realSpaceData);
    P = torch.fft.fft2(data_2d)
    
    # MATLAB: P_shifted = fftshift(P);
    P_shifted = torch.fft.fftshift(P)
    
    # MATLAB: Amp = abs(P_shifted);
    Amp = torch.abs(P_shifted)
    
    # MATLABä¸­çš„ç½‘æ ¼è®¡ç®—ï¼šè¿™é‡Œéœ€è¦æ¨¡æ‹ŸMATLABçš„ç½‘æ ¼ç”Ÿæˆ
    # MATLABçš„plotWaveNumberSpaceä¼šåŸºäºå®é™…æ•°æ®çš„å°ºå¯¸æ¥è®¡ç®—æ³¢æ•°
    # ä½†è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨å®é™…çš„ç½‘æ ¼é—´è·
    
    if xx is not None and yy is not None:
        # å¦‚æœæä¾›äº†ç©ºé—´åæ ‡ï¼Œè®¡ç®—å®é™…çš„dx, dy
        # MATLAB: dx = (xx(1,2) - xx(1,1));
        dx = (xx[0, 1] - xx[0, 0]).item()
        
        # MATLAB: dy = (yy(2,1) - yy(1,1));
        dy = (yy[1, 0] - yy[0, 0]).item()
    else:
        # å¦‚æœæ²¡æœ‰æä¾›ç©ºé—´åæ ‡ï¼Œä½¿ç”¨é»˜è®¤çš„ç½‘æ ¼é—´è·
        # è¿™é‡Œå‡è®¾å•ä½ç½‘æ ¼é—´è·
        dx = 1.0
        dy = 1.0
    
    # MATLAB: if mod(Nx, 2) == 0
    if Nx % 2 == 0:
        # MATLAB: kx = 2*pi*(-Nx/2:Nx/2-1)/((Nx-1)*dx);
        kx = 2 * np.pi * np.arange(-Nx//2, Nx//2) / ((Nx - 1) * dx)
    else:
        # MATLAB: kx = 2*pi*(-(Nx-1)/2:(Nx-1)/2)/((Nx-1)*dx);
        kx = 2 * np.pi * np.arange(-(Nx-1)//2, (Nx-1)//2 + 1) / ((Nx - 1) * dx)
    
    # MATLAB: if mod(Ny, 2) == 0
    if Ny % 2 == 0:
        # MATLAB: ky = 2*pi*(-Ny/2:Ny/2-1)/((Ny-1)*dy);
        ky = 2 * np.pi * np.arange(-Ny//2, Ny//2) / ((Ny - 1) * dy)
    else:
        # MATLAB: ky = 2*pi*(-(Ny-1)/2:(Ny-1)/2)/((Ny-1)*dy);
        ky = 2 * np.pi * np.arange(-(Ny-1)//2, (Ny-1)//2 + 1) / ((Ny - 1) * dy)
    
    # MATLAB: [KX, KY] = meshgrid(kx, ky);
    # MATLABçš„meshgridé»˜è®¤æ˜¯indexing='xy'è¡Œä¸º
    KX, KY = np.meshgrid(kx, ky, indexing='xy')
    
    # MATLAB: å½’ä¸€åŒ–å¤„ç†
    if config.FVER == 5:
        # MATLAB: kx = kx*obj.rho_ref; ky = ky*obj.rho_ref;
        kx = kx * config.rho_ref
        ky = ky * config.rho_ref
        KX = KX * config.rho_ref
        KY = KY * config.rho_ref
    else:
        # MATLAB: kx = kx*0.003; ky = ky*0.003;
        kx = kx * 0.003
        ky = ky * 0.003
        KX = KX * 0.003
        KY = KY * 0.003
    
    # MATLAB: contourf(KX, KY, log(Amp), 100, 'LineStyle', 'none');
    if save_path:
        plt.figure(figsize=(10, 8))
        plt.contourf(KX, KY, np.log(Amp.cpu().numpy()), levels=100)
        plt.xlabel('k_xÏ_i')
        plt.ylabel('k_yÏ_i')
        plt.colorbar()
        plt.title('Wavenumber Space (Figure 4)')
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
        print(f"Saved: {save_path}")
        plt.close()
    
    kx_tensor = torch.from_numpy(kx).to(real_space_data.device)
    ky_tensor = torch.from_numpy(ky).to(real_space_data.device)
    KX_tensor = torch.from_numpy(KX).to(real_space_data.device)
    KY_tensor = torch.from_numpy(KY).to(real_space_data.device)
    
    return Amp, KX_tensor, KY_tensor


#!/usr/bin/env python3
"""
PCIåˆ†æç»Ÿä¸€å…¥å£è„šæœ¬
æ”¯æŒå•æ—¶é—´ç‚¹éªŒè¯å’Œå®Œæ•´æ—¶é—´åºåˆ—åˆ†æ
"""

import sys
import json
import argparse
from pathlib import Path
from typing import Dict, Any, Optional

# æ·»åŠ pci_torchåˆ°è·¯å¾„
sys.path.insert(0, str(Path(__file__).parent))

from pci_torch.path_config import PathConfig
from pci_torch.batch_processor import process_time_series
from pci_torch.data_loader import load_gene_config_from_parameters, load_beam_config
from pci_torch.forward_model import forward_projection
from pci_torch.visualization import PCIVisualizer
import matplotlib.pyplot as plt
import torch
import numpy as np


def load_config(config_file: str = None) -> Dict[str, Any]:
    """åŠ è½½é…ç½®æ–‡ä»¶"""
    if config_file is None:
        config_file = "config/paths.json"
    
    config_path = Path(config_file)
    if not config_path.exists():
        raise FileNotFoundError(f"é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_file}")
    
    with open(config_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def run_single_time(config: Dict[str, Any], device: str = None):
    """è¿è¡Œå•æ—¶é—´ç‚¹åˆ†æ"""
    print("=" * 80)
    print("å•æ—¶é—´ç‚¹åˆ†æ")
    print("=" * 80)
    
    # åŠ è½½é…ç½®
    path_config = PathConfig.from_config_file(str(Path(__file__).parent / "config" / "paths.json"))
    path_config.create_output_dirs()
    
    # è·å–ä»»åŠ¡å‚æ•°
    task_config = config['task']
    exec_config = config['execution']
    
    # è®¾å¤‡é€‰æ‹©
    if device is None:
        device = exec_config['device']
    
    # åŠ è½½æ•°æ®é…ç½®
    print("åŠ è½½GENEé…ç½®...")
    gene_config = load_gene_config_from_parameters(
        str(path_config.parameters_file),
        str(path_config.input_dir),
        device=device
    )
    
    print("åŠ è½½å…‰æŸé…ç½®...")
    beam_config = load_beam_config(str(path_config.beam_config_file))
    
    # åŠ è½½æ•°æ®æ–‡ä»¶
    time_point = task_config['time_point']
    time_int = int(time_point * 100)
    binary_file = path_config.get_binary_data_file(time_int)
    
    print(f"æ—¶é—´ç‚¹: {time_point} (æ–‡ä»¶: {binary_file.name})")
    
    # æ£€æŸ¥å¹¶ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶
    if not binary_file.exists():
        text_file = path_config.get_time_data_file(time_int)
        if text_file.exists():
            print("ç”ŸæˆäºŒè¿›åˆ¶æ–‡ä»¶...")
            from pci_torch.data_loader import generate_timedata
            binary_file = generate_timedata(gene_config, str(text_file), time_point, str(path_config.input_dir))
        else:
            raise FileNotFoundError(f"æ•°æ®æ–‡ä»¶ä¸å­˜åœ¨: {text_file}")
    
    # æ›´æ–°é…ç½®
    gene_config.compute_derived_params()
    
    # è¯»å–å¯†åº¦åœº
    print("è¯»å–å¯†åº¦åœºæ•°æ®...")
    from pci_torch.data_loader import fread_data_s
    density_3d = fread_data_s(gene_config, str(binary_file), device=device)
    print(f"  å¯†åº¦åœºshape: {density_3d.shape}")
    
    # æ‰§è¡ŒPCIæ­£å‘æŠ•å½±
    print("æ‰§è¡ŒPCIæ­£å‘æŠ•å½±...")
    pci_result, debug_info = forward_projection(
        density_3d, gene_config, beam_config, 
        device=device, return_line_integral=True, return_debug_info=True  # DEBUG: è®¾ç½®ä¸ºTrueè·å–ä¸­é—´æ•°æ®
    )
    
    # ä¿å­˜ç»“æœ
    print("ä¿å­˜ç»“æœ...")
    output_path = path_config.output_dir / f"single_time_t{time_point:.2f}_var{task_config['var_type']}.mat"
    
    # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    output_path.parent.mkdir(parents=True, exist_ok=True)
    
    # ä¿å­˜ä¸ºMATLABå…¼å®¹æ ¼å¼
    try:
        import scipy.io as sio
        
        # ä¿å­˜è°ƒè¯•ä¿¡æ¯
        debug_data = {
            'pci_signal': pci_result.cpu().numpy(),
            'time_point': time_point,
            'var_type': task_config['var_type'],
            'data_n': task_config['data_n'],
            'device': device
        }
        
        # æ·»åŠ MATLABå…¼å®¹çš„å˜é‡å
        pci_np = pci_result.cpu().numpy()
        
        # ç¡®ä¿numpyåœ¨ä½œç”¨åŸŸå†…å¯ç”¨
        import numpy as np
        # pout: æ²¿å…‰æŸè·¯å¾„çš„1Dä¿¡å·ï¼ˆå–ä¸­å¿ƒæ£€æµ‹å™¨ä½ç½®çš„å¹³å‡ï¼‰
        center_v = pci_np.shape[0] // 2  # å‚ç›´ä¸­å¿ƒ
        center_t = pci_np.shape[1] // 2  # ç¯å‘ä¸­å¿ƒ
        pout = pci_np[center_v, center_t, :].flatten()  # 1Dä¿¡å·å¯¹åº”MATLABçš„plot(abs(pout))
        debug_data['pout'] = pout
        
        # pout2: 2Dæ£€æµ‹å™¨ä¿¡å·ï¼ˆå–å…‰æŸä¸­ç‚¹ï¼‰
        # ä¿®å¤ï¼šä¸è¦åªå–ä¸­é—´ç‚¹ï¼Œå¯èƒ½è¯¥ç‚¹æ•°æ®ä¸º0
        center_beam = pci_np.shape[2] // 2
        
        # å°è¯•å¤šä¸ªæ—¶é—´ç‚¹ï¼Œçœ‹å“ªä¸ªæœ‰æœ‰æ•ˆæ•°æ®
        candidate_points = [center_beam, center_beam//2, center_beam*3//2, 0, pci_np.shape[2]-1]
        pout2 = None
        
        for pt in candidate_points:
            if pt < pci_np.shape[2]:
                temp_pout2 = pci_np[:, :, pt]
                if np.any(np.abs(temp_pout2) > 1e-6):  # æ£€æŸ¥æ˜¯å¦æœ‰éé›¶æ•°æ®
                    pout2 = temp_pout2
                    break
        
        # å¦‚æœæ‰€æœ‰å€™é€‰ç‚¹éƒ½æ˜¯0ï¼Œå–æ‰€æœ‰æ—¶é—´ç‚¹çš„å¹³å‡
        if pout2 is None or np.all(np.abs(pout2) < 1e-6):
            pout2 = np.mean(pci_np, axis=2)  # æ²¿å…‰æŸè·¯å¾„å–å¹³å‡
            # å¦‚æœå¹³å‡è¿˜æ˜¯0ï¼Œå–æœ€å¤§å€¼æ—¶é—´ç‚¹
            if np.all(np.abs(pout2) < 1e-6):
                max_indices = np.unravel_index(np.argmax(np.abs(pci_np), axis=None), pci_np.shape)
                pout2 = pci_np[:, :, max_indices[2]]
        else:
            pout2 = pout2
        debug_data['pout2'] = pout2
        
        # å¦‚æœæœ‰ä¸­é—´ç»“æœï¼Œä¹Ÿä¿å­˜
        if 'debug_info' in locals():
            import torch
            for key, value in debug_info.items():
                if isinstance(value, torch.Tensor):
                    debug_data[key] = value.cpu().numpy()
                else:
                    debug_data[key] = value
        
        sio.savemat(str(output_path), debug_data)
        print(f"  ç»“æœå·²ä¿å­˜: {output_path}")
        
        # åŒæ—¶ä¿å­˜NPZæ ¼å¼ç”¨äºè¯¦ç»†åˆ†æ
        npz_path = output_path.with_suffix('.npz')
        import torch
        import numpy as np
        npz_data = {k: v.cpu().numpy() if isinstance(v, torch.Tensor) else v 
                   for k, v in debug_data.items()}
        np.savez(str(npz_path), **npz_data)
        print(f"  è°ƒè¯•æ•°æ®å·²ä¿å­˜: {npz_path}")
        
    except ImportError:
        # å¦‚æœæ²¡æœ‰scipyï¼Œä¿å­˜ä¸ºnumpyæ ¼å¼
        numpy_path = output_path.with_suffix('.npy')
        import torch
        torch.save(pci_result.cpu(), numpy_path)
        print(f"  ç»“æœå·²ä¿å­˜: {numpy_path}")
    
    # ç”Ÿæˆå¯è§†åŒ–
    if exec_config.get('save_detailed_results', True):
        print("ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨...")
        visualizer = PCIVisualizer(gene_config)
        
        # ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
        path_config.figures_dir.mkdir(parents=True, exist_ok=True)
        
        # 1. 3Då…‰æŸå‡ ä½•å›¾ (Figure 1 - å¯¹åº”MATLAB)
        print("  Generating 3D beam geometry plot...")
        from pci_torch.beam_geometry import compute_beam_grid
        beam_grid = compute_beam_grid(beam_config, device)
        beam_fig_path = path_config.figures_dir / f"fig1_beam_geometry_t{time_point:.2f}.png"
        visualizer.plot_beam_geometry_3d(beam_grid, str(beam_fig_path))
        
        # 2. æ£€æµ‹å™¨ä¿¡å·ç­‰é«˜çº¿å›¾ (Figure 3 - å¯¹åº”MATLAB)
        print("  Generating detector signal contour plot...")
        detector_fig_path = path_config.figures_dir / f"fig3_detector_signal_t{time_point:.2f}.png"
        visualizer.plot_detector_contour(
            pci_result, beam_config, time_point, str(detector_fig_path)
        )
        
        # 3. å¯†åº¦åœºpoloidalæˆªé¢å›¾ -> ä¿®æ­£ä¸ºæ²¿å…‰æŸè·¯å¾„çš„PCIä¿¡å·åˆ†å¸ƒå›¾
        print("  Generating beam path PCI signal distribution plot...")
        # è·å–æ²¿å…‰æŸè·¯å¾„çš„PCIä¿¡å·ï¼ˆå¯¹åº”MATLABçš„poutï¼‰
        pci_result, debug_info = forward_projection(
            density_3d, gene_config, beam_config, 
            device=device, return_line_integral=True, return_debug_info=True
        )
        # pci_resultå½¢çŠ¶: (n_det_v, n_det_t, n_beam_points)
        # éœ€è¦flattenåˆ°1Dä¿¡å·ç”¨äºç»˜å›¾
        pci_signal_1d = pci_result.flatten()  # å¯¹åº”MATLABçš„abs(pout)
        
        # ç”Ÿæˆä¿¡å·åˆ†å¸ƒå›¾
        beam_signal_fig_path = path_config.figures_dir / f"fig2_density_poloidal_t{time_point:.2f}.png"
        create_beam_path_signal_plot(pci_signal_1d, str(beam_signal_fig_path))
        
        # 4. 2Dæ³¢æ•°ç©ºé—´å›¾ (Figure 4 - å¯¹åº”MATLAB)
        print("  Generating 2D wavenumber space plot...")
        from pci_torch.visualization import plot_wavenumber_space_2d
        wavenumber_fig_path = path_config.figures_dir / f"fig4_wavenumber_space_t{time_point:.2f}.png"
        plot_wavenumber_space_2d(
            None, None, pci_result, gene_config, str(wavenumber_fig_path)
        )
        
        # 5. å…‰æŸä½ç½®å›¾
        print("  ç”Ÿæˆå…‰æŸä½ç½®å›¾...")
        # è¿™é‡Œå¯ä»¥æ·»åŠ å…‰æŸä½ç½®çš„å¯è§†åŒ–ï¼Œå¦‚æœéœ€è¦çš„è¯
        
        print("  æ‰€æœ‰å›¾è¡¨å·²ä¿å­˜")
    
    # ç»Ÿè®¡ä¿¡æ¯
    print(f"ä¿¡å·ç»Ÿè®¡:")
    print(f"  èŒƒå›´: [{pci_result.min():.6f}, {pci_result.max():.6f}]")
    print(f"  å‡å€¼: {pci_result.mean():.6f}")
    print(f"  æ ‡å‡†å·®: {pci_result.std():.6f}")
    
    return pci_result

def run_time_series(config: Dict[str, Any], device: str = None):
    """è¿è¡Œæ—¶é—´åºåˆ—åˆ†æ"""
    print("=" * 80)
    print("æ—¶é—´åºåˆ—åˆ†æ")
    print("=" * 80)
    
    # åŠ è½½é…ç½®
    path_config = PathConfig.from_config_file("config/paths.json")
    path_config.create_output_dirs()
    
    # è·å–ä»»åŠ¡å‚æ•°
    task_config = config['task']
    exec_config = config['execution']
    
    # è®¾å¤‡é€‰æ‹©
    if device is None:
        device = exec_config['device']
    
    # åŠ è½½æ•°æ®é…ç½®
    print("åŠ è½½GENEé…ç½®...")
    gene_config = load_gene_config_from_parameters(
        str(path_config.parameters_file),
        str(path_config.input_dir),
        device=device
    )
    
    print("åŠ è½½å…‰æŸé…ç½®...")
    beam_config = load_beam_config(str(path_config.beam_config_file))
    
    # æ‰§è¡Œæ—¶é—´åºåˆ—å¤„ç†
    print("æ‰§è¡Œæ—¶é—´åºåˆ—å¤„ç†...")
    pout1, pout2 = process_time_series(
        str(path_config.input_dir),
        task_config['data_n'],
        gene_config,
        beam_config,
        var=task_config['var_type'],
        device=device,
        save_results=True,
        output_dir=str(path_config.mat_dir)
    )
    
    print(f"æ—¶é—´åºåˆ—å¤„ç†å®Œæˆ!")
    print(f"  LocalCross-Section shape: {pout1.shape}")
    print(f"  IntegratedSignal shape: {pout2.shape}")
    
    return pout1, pout2

def create_beam_path_signal_plot(pci_signal_1d, save_path):Figure 2: PCIä¿¡å·å¼ºåº¦å›¾

    """ç”Ÿæˆæ²¿å…‰æŸè·¯å¾„çš„PCIä¿¡å·åˆ†å¸ƒå›¾ï¼ˆå¯¹åº”MATLABçš„plot(abs(pout))ï¼‰
    
    Args:
        pci_signal_1d: 1D PCIä¿¡å·æ•°ç»„
        save_path: å›¾ç‰‡ä¿å­˜è·¯å¾„
    """
    fig = plt.figure(figsize=(12, 8))
    
    # è®¡ç®—ä¿¡å·ç»å¯¹å€¼ï¼ˆå¯¹åº”MATLABçš„abs(pout)ï¼‰
    signal_abs = torch.abs(pci_signal_1d)
    signal_np = signal_abs.cpu().numpy()
    
    # ç»˜åˆ¶ä¿¡å·åˆ†å¸ƒ
    plt.plot(signal_np, 'b-', linewidth=1.5, label='PCI Signal')
    plt.xlabel('Beam Path Point')
    plt.ylabel('Signal Magnitude')
    plt.title('PCI Signal Distribution Along Beam Path (Figure 2)')
    plt.grid(True, alpha=0.3)
    plt.legend()
    
    # æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
    max_val = signal_np.max()
    min_val = signal_np.min()
    mean_val = signal_np.mean()
    plt.text(0.02, 0.98, f'Max: {max_val:.2f}\nMin: {min_val:.2f}\nMean: {mean_val:.2f}', 
             transform=plt.gca().transAxes, verticalalignment='top',
             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
    
    plt.tight_layout()
    plt.savefig(save_path, dpi=150, bbox_inches='tight')
    print(f"  Beam path signal plot saved: {save_path}")
    plt.close()

def main():
    """ä¸»å‡½æ•°"""
    parser = argparse.ArgumentParser(description='PCIåˆ†æç»Ÿä¸€å…¥å£')
    parser.add_argument('--config', type=str, default='config/paths.json',
                       help='é…ç½®æ–‡ä»¶è·¯å¾„')
    parser.add_argument('--task', type=str, choices=['single_time', 'time_series'],
                       help='ä»»åŠ¡ç±»å‹ (è¦†ç›–é…ç½®æ–‡ä»¶)')
    parser.add_argument('--device', type=str, choices=['cpu', 'cuda', 'hip'],
                       help='è®¡ç®—è®¾å¤‡ (è¦†ç›–é…ç½®æ–‡ä»¶)')
    parser.add_argument('--time', type=float,
                       help='æ—¶é—´ç‚¹ (ä»…å•æ—¶é—´ç‚¹ä»»åŠ¡)')
    parser.add_argument('--var', type=int, choices=[1, 2, 3, 4, 5],
                       help='å˜é‡ç±»å‹ (è¦†ç›–é…ç½®æ–‡ä»¶)')
    parser.add_argument('--data_n', type=int,
                       help='æ•°æ®ç¼–å· (è¦†ç›–é…ç½®æ–‡ä»¶)')
    
    args = parser.parse_args()
    
    try:
        # åŠ è½½é…ç½®
        config = load_config(args.config)
        
        # æ™ºèƒ½è®¾å¤‡æ£€æµ‹
        if args.device == 'cuda':
            import torch
            if torch.cuda.is_available():
                print(f"  æ£€æµ‹åˆ°å¯ç”¨GPU: {torch.cuda.get_device_name(0)}")
                print(f"  GPUæ¶æ„: {torch.version.hip if hasattr(torch.version, 'hip') else 'CUDA'}")
            else:
                print("  è­¦å‘Š: æŒ‡å®šäº†GPUä½†ç³»ç»Ÿæ— å¯ç”¨GPUï¼Œå›é€€åˆ°CPU")
                args.device = 'cpu'
        
        # è¦†ç›–é…ç½®å‚æ•°
        if args.task:
            config['task']['type'] = args.task
        if args.device:
            config['execution']['device'] = args.device
        if args.time:
            config['task']['time_point'] = args.time
        if args.var:
            config['task']['var_type'] = args.var
        if args.data_n:
            config['task']['data_n'] = args.data_n
        
        # æ˜¾ç¤ºé…ç½®
        print("é…ç½®ä¿¡æ¯:")
        print(f"  ä»»åŠ¡ç±»å‹: {config['task']['type']}")
        print(f"  æ•°æ®ç¼–å·: {config['task']['data_n']}")
        print(f"  å˜é‡ç±»å‹: {config['task']['var_type']} (1:potential, 2:A, 3:v, 4:n, 5:Te)")
        print(f"  è®¡ç®—è®¾å¤‡: {config['execution']['device']}")
        
        if config['task']['type'] == 'single_time':
            print(f"  æ—¶é—´ç‚¹: {config['task']['time_point']}")
        
        print()
        
        # æ‰§è¡Œä»»åŠ¡
        if config['task']['type'] == 'single_time':
            result = run_single_time(config, args.device)
        elif config['task']['type'] == 'time_series':
            result = run_time_series(config, args.device)
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„ä»»åŠ¡ç±»å‹: {config['task']['type']}")
        
        print("\n" + "=" * 80)
        print("ä»»åŠ¡å®Œæˆ!")
        print("=" * 80)
        
    except Exception as e:
        print(f"é”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()


"""
å…‰æŸå‡ ä½•è®¡ç®—

ç”ŸæˆPCIå…‰æŸçš„é‡‡æ ·ç½‘æ ¼å’Œå…‰è·¯è®¡ç®—
"""

import torch
import numpy as np
from typing import Dict, Tuple
from .config import BeamConfig, GENEConfig


def compute_beam_grid(
    beam_config: BeamConfig,
    config: GENEConfig = None,
    device: str = 'cuda'
) -> Dict[str, torch.Tensor]:
    """
    è®¡ç®—å…‰æŸç½‘æ ¼çš„æ‰€æœ‰é‡‡æ ·ç‚¹ï¼ˆç¬›å¡å°”åæ ‡ï¼‰
    
    ä¸¥æ ¼æŒ‰ç…§MATLAB LSview_com.m è¡Œ62-133å®ç°
    
    Args:
        beam_config: å…‰æŸé…ç½®
        device: PyTorchè®¾å¤‡
    
    Returns:
        å­—å…¸åŒ…å«:
            - 'grid_xyz': (div1*2+1, div2*2+1, divls+1, 3) ç½‘æ ¼ç‚¹ç¬›å¡å°”åæ ‡
            - 'grid_flat': (N, 3) å±•å¹³çš„åæ ‡ï¼ŒN = (2*div1+1)*(2*div2+1)*(divls+1)
            - 'beam_vector': (3,) å…‰æŸæ–¹å‘å•ä½å‘é‡
            - 'perpendicular_vectors': (2, 3) ä¸¤ä¸ªå‚ç›´å‘é‡
    """
    # ==============================================================================
    # å¢å¼ºè¾“å‡º1: åŸå§‹å…‰æŸé…ç½®æ•°æ®
    # ==============================================================================
    print(f'\n=== PYTHON BEAM CONFIG DATA ===')
    print(f'æ³¨å…¥ç‚¹: {beam_config.injection_point}')
    print(f'æ£€æµ‹ç‚¹: {beam_config.detection_point}')
    print(f'width_vertical: {beam_config.width_vertical} m')
    print(f'width_toroidal: {beam_config.width_toroidal} m')
    print(f'div_vertical: {beam_config.div_vertical}')
    print(f'div_toroidal: {beam_config.div_toroidal}')
    print(f'div_beam: {beam_config.div_beam}')
    
    # MATLAB ç¬¬62-70è¡Œ: åæ ‡è½¬æ¢
    # B1(1,:) = pp1(1:3) - èµ·ç‚¹ (R[m], Z[m], phi[0-1])
    # B1(2,:) = pp1(4:6) - ç»ˆç‚¹
    # âœ… ä¿®æ­£: BeamConfigä¸­å·²ç»æ˜¯ç±³å•ä½ï¼Œä¸éœ€è¦å†é™¤ä»¥1000
    B1_start = np.array([
        beam_config.injection_point[0],  # R [m] (å·²ç»æ˜¯è½¬æ¢åçš„)
        beam_config.injection_point[2],  # phi [0-1] (ä¿®æ­£: åº”è¯¥æ˜¯phi)
        beam_config.injection_point[1]   # Z [m] (ä¿®æ­£: åº”è¯¥æ˜¯Z)
    ])
    B1_end = np.array([
        beam_config.detection_point[0],   # R [m] (å·²ç»æ˜¯è½¬æ¢åçš„)
        beam_config.detection_point[2],   # phi [0-1] (ä¿®æ­£: åº”è¯¥æ˜¯phi)
        beam_config.detection_point[1]    # Z [m] (ä¿®æ­£: åº”è¯¥æ˜¯Z)
    ])
    
    # ==============================================================================
    # å¢å¼ºè¾“å‡º2: åæ ‡è½¬æ¢ (R,Z,phi) -> (X,Y,Z)
    # ==============================================================================
    print(f'\n=== PYTHON COORDINATE CONVERSION ===')
    print(f'B1_start (åŸå§‹åæ ‡m): [{B1_start[0]:.6f}, {B1_start[1]:.6f}, {B1_start[2]:.6f}]')
    print(f'B1_end (åŸå§‹åæ ‡m): [{B1_end[0]:.6f}, {B1_end[1]:.6f}, {B1_end[2]:.6f}]')
    
    # B2(:,1) = B1(:,1).*cos(2*pi*B1(:,2)) - Xåæ ‡ (R * cos(2Ï€ * phi))
    # B2(:,2) = B1(:,1).*sin(2*pi*B1(:,2)) - Yåæ ‡ (R * sin(2Ï€ * phi))  
    # B2(:,3) = B1(:,3) - Zåæ ‡
    # âœ… ä¿®æ­£: B1å·²ç»æ˜¯må•ä½ï¼Œä½†ä»éœ€è¦ä¿æŒä¸MATLABä¸€è‡´çš„é€»è¾‘
    # å…³é”®ä¿®æ­£: B2_startåº”è¯¥æ˜¯æ³¨å…¥ç‚¹ï¼ŒB2_endåº”è¯¥æ˜¯æ£€æµ‹ç‚¹
    B2_start = np.array([
        B1_start[0] * np.cos(2 * np.pi * B1_start[1]),  # æ³¨å…¥ç‚¹çš„ç¬›å¡å°”åæ ‡ (R * cos(2Ï€ * phi))
        B1_start[0] * np.sin(2 * np.pi * B1_start[1]),
        B1_start[2]  # Zåæ ‡
    ])
    
    B2_end = np.array([
        B1_end[0] * np.cos(2 * np.pi * B1_end[1]),     # æ£€æµ‹ç‚¹çš„ç¬›å¡å°”åæ ‡ (R * cos(2Ï€ * phi))
        B1_end[0] * np.sin(2 * np.pi * B1_end[1]),
        B1_end[2]  # Zåæ ‡
    ])
    
    # æ³¨æ„: Pythonä¸­å·²ç»åœ¨data_loader.pyä¸­å¤„ç†äº†æ¯«ç±³åˆ°ç±³çš„è½¬æ¢
    # injection_point = (coords[0] / 1000.0, coords[1] / 1000.0, coords[2])
    # å› æ­¤B1_startå·²ç»æ˜¯ç±³å•ä½ï¼Œä¸éœ€è¦å†é™¤ä»¥1000
    
    print(f'B2_start (è½¬æ¢ååæ ‡): [{B2_start[0]:.6f}, {B2_start[1]:.6f}, {B2_start[2]:.6f}]')
    print(f'B2_end (è½¬æ¢ååæ ‡): [{B2_end[0]:.6f}, {B2_end[1]:.6f}, {B2_end[2]:.6f}]')
    
    # è½¬æ¢ä¸ºtorch tensor - DEBUG: ä¿®å¤è®¾å¤‡åˆå§‹åŒ–é—®é¢˜
    try:
        B2_start = torch.tensor(B2_start, dtype=torch.float64, device=device).detach().clone()
        B2_end = torch.tensor(B2_end, dtype=torch.float64, device=device).detach().clone()
    except RuntimeError as e:
        if "Found no NVIDIA driver" in str(e):
            print("è­¦å‘Š: æ£€æµ‹åˆ°GPUé©±åŠ¨é—®é¢˜ï¼Œåˆ‡æ¢åˆ°CPUæ¨¡å¼")
            device = 'cpu'
        else:
            raise e
    
    # MATLAB ç¬¬71-74è¡Œ: è®¡ç®—å…‰æŸé•¿åº¦
    # b2ls = sqrt((B2(1,1)-B2(2,1))^2 + (B2(1,2)-B2(2,2))^2 + (B2(1,3)-B2(2,3))^2)
    
    # ğŸ”§ ä¿®å¤numpy/torchæ··ç”¨é—®é¢˜ï¼šç¡®ä¿è®¡ç®—ä½¿ç”¨torchå¼ é‡
    diff_x = B2_start[0] - B2_end[0]
    diff_y = B2_start[1] - B2_end[1] 
    diff_z = B2_start[2] - B2_end[2]
    
    # ç¡®ä¿å·®å€¼æ˜¯torch.tensorç±»å‹
    if not isinstance(diff_x, torch.Tensor):
        diff_x = torch.tensor(diff_x, device=device, dtype=torch.float64).detach().clone()
    if not isinstance(diff_y, torch.Tensor):
        diff_y = torch.tensor(diff_y, device=device, dtype=torch.float64).detach().clone()
    if not isinstance(diff_z, torch.Tensor):
        diff_z = torch.tensor(diff_z, device=device, dtype=torch.float64).detach().clone()
    
    b2ls = torch.sqrt(diff_x**2 + diff_y**2 + diff_z**2)
    
    # MATLAB ç¬¬76-78è¡Œ: è®¡ç®—å…‰æŸæ–¹å‘å‘é‡
    # âš ï¸ å…³é”®ä¿®æ­£: MATLABä¸­p1 = B2(èµ·ç‚¹) - B2(ç»ˆç‚¹) = ä»ç»ˆç‚¹æŒ‡å‘èµ·ç‚¹ï¼
    # ä¸æˆ‘ä»¬ä¹‹å‰ç†è§£çš„B2_end - B2_startç›¸å
    p1 = torch.zeros(3, dtype=torch.float64, device=device)
    p1[0] = B2_start[0] - B2_end[0]  # ä¿®æ­£: ä¸MATLABä¸€è‡´ - ä»ç»ˆç‚¹æŒ‡å‘èµ·ç‚¹
    p1[1] = B2_start[1] - B2_end[1]
    p1[2] = B2_start[2] - B2_end[2]
    
    # ==============================================================================
    # å¢å¼ºè¾“å‡º3: å…‰æŸæ–¹å‘å‘é‡
    # ==============================================================================
    print(f'\n=== PYTHON BEAM VECTOR ===')
    print(f'p1 (B2_end - B2_start): [{p1[0]:.6f}, {p1[1]:.6f}, {p1[2]:.6f}]')
    print(f'p1 magnitude: {torch.norm(p1):.6f}')
    print(f'b2ls (å…‰æŸæ€»é•¿åº¦): {b2ls:.6f}')
    
    # è®¡ç®—å•ä½å‘é‡
    p1_unit = p1 / torch.norm(p1)
    
    # MATLAB ç¬¬80-102è¡Œ: è®¡ç®—å‚ç›´å‘é‡
    xl = torch.zeros(2, 3, dtype=torch.float64, device=device)
    wid1 = beam_config.width_vertical
    wid2 = beam_config.width_toroidal
    
    # ä½¿ç”¨åŸå§‹ phi å€¼ B1(1,3)ï¼ŒèŒƒå›´ [0-1]
    phi_raw = B1_start[2]  # åŸå§‹ phi å€¼ï¼ŒèŒƒå›´ [0-1]
    
    # ==============================================================================
    # å¢å¼ºè¾“å‡º4: å‚ç›´å‘é‡è®¡ç®—
    # ==============================================================================
    print(f'\n=== PYTHON PERPENDICULAR VECTORS ===')
    
    # æ£€æŸ¥å…‰æŸæ˜¯å¦å‚ç›´ï¼ˆp1(1)==0 && p1(2)==0ï¼‰
    if torch.abs(p1[0]) < 1e-10 and torch.abs(p1[1]) < 1e-10:
        # MATLAB ç¬¬81-86è¡Œ: å‚ç›´å…‰æŸçš„æƒ…å†µ
        print(f'  å‚ç›´å…‰æŸæƒ…å†µ')
        phi_rad = 2 * np.pi * phi_raw
        xl[0, 0] = wid1 / 2.0 * np.cos(phi_rad)
        xl[0, 1] = wid1 / 2.0 * np.sin(phi_rad)
        xl[0, 2] = 0.0
        xl[1, 0] = -wid2 / 2.0 * np.sin(phi_rad)
        xl[1, 1] = wid2 / 2.0 * np.cos(phi_rad)
        xl[1, 2] = 0.0
    else:
        # MATLAB ç¬¬87-101è¡Œ: ä¸€èˆ¬æƒ…å†µ
        print(f'  ä¸€èˆ¬å…‰æŸæƒ…å†µ')
        phi_rad = 2 * np.pi * phi_raw
        tan_phi = np.tan(phi_rad)
        tan_phi_t = torch.tensor(tan_phi, dtype=torch.float64, device=device).detach().clone()
        
        # ç¬¬ä¸€ä¸ªå‚ç›´å‘é‡ï¼ˆMATLABç¬¬88-94è¡Œï¼‰
        xl[0, 0] = p1[2]
        xl[0, 1] = p1[2] * tan_phi_t
        xl[0, 2] = -(p1[0] + p1[1] * tan_phi_t)
        xl0 = 1.0 / torch.norm(xl[0]) * (wid1 / 2.0)
        xl[0, 0] = xl[0, 0] * xl0
        xl[0, 1] = xl[0, 1] * xl0
        xl[0, 2] = xl[0, 2] * xl0
        
        # ç¬¬äºŒä¸ªå‚ç›´å‘é‡ï¼ˆMATLABç¬¬95-101è¡Œï¼‰
        xl[1, 0] = p1[0] * p1[1] + (p1[1]**2 + p1[2]**2) * tan_phi_t
        xl[1, 1] = -p1[0]**2 - p1[2]**2 - p1[0] * p1[1] * tan_phi_t
        xl[1, 2] = p1[1] * p1[2] - p1[0] * p1[2] * tan_phi_t
        xl0 = 1.0 / torch.norm(xl[1]) * (wid2 / 2.0)
        xl[1, 0] = xl[1, 0] * xl0
        xl[1, 1] = xl[1, 1] * xl0
        xl[1, 2] = xl[1, 2] * xl0
    
    print(f'xl[0,:] (å‚ç›´å‘é‡1): [{xl[0,0]:.6f}, {xl[0,1]:.6f}, {xl[0,2]:.6f}]')
    print(f'xl[1,:] (å‚ç›´å‘é‡2): [{xl[1,0]:.6f}, {xl[1,1]:.6f}, {xl[1,2]:.6f}]')
    print(f'xl[0,:] magnitude: {torch.norm(xl[0]):.6f}')
    print(f'xl[1,:] magnitude: {torch.norm(xl[1]):.6f}')
    
    # è®¡ç®—å•ä½å‘é‡ï¼ˆç”¨äºè¿”å›ï¼‰
    xl_unit = torch.zeros_like(xl)
    xl_unit[0] = xl[0] / torch.norm(xl[0])
    xl_unit[1] = xl[1] / torch.norm(xl[1])
    
    # MATLAB ç¬¬103-107è¡Œ: ç½‘æ ¼å‚æ•°
    div1 = beam_config.div_vertical
    div2 = beam_config.div_toroidal
    divls = beam_config.div_beam
    divls_2 = divls + 1
    div1_2 = 2 * div1 + 1
    div2_2 = 2 * div2 + 1
    
    # MATLAB ç¬¬107è¡Œ: b2ls = b2ls/divls (è¿™æ˜¯æ­¥é•¿ï¼Œä¸æ˜¯æ€»é•¿åº¦)
    # æ³¨æ„ï¼šMATLAB ä¸­ b2ls è¢«é‡æ–°èµ‹å€¼ä¸ºæ­¥é•¿
    b2ls_step = b2ls / divls
    
    # ==============================================================================
    # å¢å¼ºè¾“å‡º5: ç½‘æ ¼å°ºå¯¸ä¿¡æ¯
    # ==============================================================================
    print(f'\n=== PYTHON GRID DIMENSIONS ===')
    print(f'div1_2 (å‚ç›´ç½‘æ ¼ç‚¹æ•°): {div1_2}')
    print(f'div2_2 (ç¯å‘ç½‘æ ¼ç‚¹æ•°): {div2_2}')
    print(f'divls_2 (å…‰æŸæ–¹å‘ç‚¹æ•°): {divls_2}')
    print(f'æ€»ç½‘æ ¼ç‚¹æ•°: {div1_2 * div2_2 * divls_2}')
    print(f'b2ls/divls (æ­¥é•¿): {b2ls_step:.6f}')
    
    # MATLAB ç¬¬108-111è¡Œ: åˆå§‹åŒ–ç½‘æ ¼ï¼ˆä»æ£€æµ‹ç‚¹å¼€å§‹ï¼‰
    # âš ï¸ å…³é”®ä¿®æ­£: åº”è¯¥ä»æ£€æµ‹ç‚¹(B2_end)å¼€å§‹ï¼Œä¸æ˜¯æ³¨å…¥ç‚¹(B2_start)
    xls = torch.ones(div1_2, div2_2, divls_2, device=device) * B2_end[0]
    yls = torch.ones(div1_2, div2_2, divls_2, device=device) * B2_end[1]
    zls = torch.ones(div1_2, div2_2, divls_2, device=device) * B2_end[2]
    
    print(f'\n=== PYTHON GRID INITIALIZATION ===')
    print(f'åˆå§‹ç½‘æ ¼ä»B2_endå¼€å§‹ (æ£€æµ‹ç‚¹): [{B2_end[0]:.6f}, {B2_end[1]:.6f}, {B2_end[2]:.6f}]')
    
    # MATLAB ç¬¬113-118è¡Œ: æ·»åŠ å‚ç›´æ–¹å‘1çš„åç§»
    # MATLAB: for j=1:div1_2, replix(j,:,:)=ones(div2_2,divls_2)*(real(j-1)-div1)/div1
    # Python: j ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥ (j - div1) / div1 ç­‰ä»·äº MATLAB çš„ (real(j-1)-div1)/div1
    for j in range(div1_2):
        offset = (j - div1) / div1  # å¯¹åº” MATLAB çš„ (real(j-1)-div1)/div1
        xls[j, :, :] = xls[j, :, :] + offset * xl[0, 0]
        yls[j, :, :] = yls[j, :, :] + offset * xl[0, 1]
        zls[j, :, :] = zls[j, :, :] + offset * xl[0, 2]
    
    # MATLAB ç¬¬119-124è¡Œ: æ·»åŠ å‚ç›´æ–¹å‘2çš„åç§»
    # MATLAB: for j=1:div2_2, replix(:,j,:)=ones(div1_2,divls_2)*(real(j-1)-div2)/div2
    for j in range(div2_2):
        offset = (j - div2) / div2  # å¯¹åº” MATLAB çš„ (real(j-1)-div2)/div2
        xls[:, j, :] = xls[:, j, :] + offset * xl[1, 0]
        yls[:, j, :] = yls[:, j, :] + offset * xl[1, 1]
        zls[:, j, :] = zls[:, j, :] + offset * xl[1, 2]
    
    # MATLAB ç¬¬125-130è¡Œ: æ·»åŠ å…‰æŸæ–¹å‘çš„åç§»
    # MATLAB: for j=1:divls_2, replix(:,:,j)=ones(div1_2,div2_2)*real(j-1)/divls
    # MATLAB ä¸­ j ä» 1 å¼€å§‹ï¼Œæ‰€ä»¥ real(j-1)/divls å½“ j=1 æ—¶ä¸º 0ï¼Œå½“ j=divls_2 æ—¶ä¸º divls/divls=1
    # Python ä¸­ j ä» 0 å¼€å§‹ï¼Œæ‰€ä»¥ j/divls å½“ j=0 æ—¶ä¸º 0ï¼Œå½“ j=divls_2-1 æ—¶ä¸º (divls_2-1)/divls = divls/divls=1
    # æ³¨æ„ï¼šdivls_2 = divls + 1ï¼Œæ‰€ä»¥ j çš„èŒƒå›´æ˜¯ [0, divls]ï¼Œæœ€åä¸€ä¸ª j=divls æ—¶ offset=divls/divls=1
    
    for j in range(divls_2):
        offset = j / divls
        xls[:, :, j] = xls[:, :, j] + offset * p1[0]
        yls[:, :, j] = yls[:, :, j] + offset * p1[1]
        zls[:, :, j] = zls[:, :, j] + offset * p1[2]
    
    # MATLAB ç¬¬131-133è¡Œ: å±•å¹³
    # MATLAB: xls1=reshape(xls,div1_2*div2_2*divls_2,1)
    xls1 = xls.reshape(div1_2 * div2_2 * divls_2)
    yls1 = yls.reshape(div1_2 * div2_2 * divls_2)
    zls1 = zls.reshape(div1_2 * div2_2 * divls_2)
    
    # ==============================================================================
    # å¢å¼ºè¾“å‡º6: ç½‘æ ¼ç‚¹æ ·æœ¬
    # ==============================================================================
    print(f'\n=== PYTHON GRID SAMPLES ===')
    print(f'å‰5ä¸ªç½‘æ ¼ç‚¹:')
    for i in range(min(5, len(xls1))):
        print(f'  ç‚¹{i+1}: [{xls1[i]:.6f}, {yls1[i]:.6f}, {zls1[i]:.6f}]')
    print(f'å5ä¸ªç½‘æ ¼ç‚¹:')
    for i in range(max(0, len(xls1)-5), len(xls1)):
        print(f'  ç‚¹{i+1}: [{xls1[i]:.6f}, {yls1[i]:.6f}, {zls1[i]:.6f}]')
    
    # å †å æˆç½‘æ ¼
    grid_xyz = torch.stack([xls, yls, zls], dim=-1)  # (div1_2, div2_2, divls_2, 3)
    
    # ğŸ”§ å…³é”®ä¿®å¤: ä¿æŒbeamåæ ‡ä¸ºç‰©ç†åæ ‡ï¼Œä¸åº”ç”¨L_refç¼©æ”¾
    if config is not None and hasattr(config, 'L_ref') and config.L_ref is not None:
        print(f'\n=== L_REF SCALING NOT APPLIED (BEAM IN PHYSICAL UNITS) ===')
        print(f'L_ref: {config.L_ref:.6f}')
        print(f'grid_xyzèŒƒå›´: [{grid_xyz.min():.6f}, {grid_xyz.max():.6f}]')
        print(f'Beamåæ ‡ä¿æŒç‰©ç†å•ä½ï¼Œä¸GAC*l_refçš„ç‰©ç†åæ ‡ç³»ç»ŸåŒ¹é…')
        # ä¸åº”ç”¨ä»»ä½•ç¼©æ”¾ï¼Œä¿æŒç‰©ç†åæ ‡
    
    # å±•å¹³ä¸º (N, 3)
    grid_flat = torch.stack([xls1, yls1, zls1], dim=-1)  # (N, 3)
    
    # ==============================================================================
    # å¢å¼ºè¾“å‡º7: ä¿å­˜å…³é”®æ•°æ®åˆ°æ–‡ä»¶
    # ==============================================================================
    print(f'\n=== SAVING PYTHON DATA ===')
    
    # ä¿å­˜åˆ°æ–‡ä»¶ç”¨äºå¯¹æ¯”
    try:
        # ä¿å­˜numpyæ ¼å¼
        np.save('/tmp/python_beam_grid.npy', grid_xyz.cpu().numpy())
        np.save('/tmp/python_grid_flat.npy', grid_flat.cpu().numpy())
        np.save('/tmp/python_beam_start.npy', B2_start.cpu().numpy())
        np.save('/tmp/python_beam_end.npy', B2_end.cpu().numpy())
        np.save('/tmp/python_beam_vector.npy', p1.cpu().numpy())
        np.save('/tmp/python_perp_vectors.npy', xl.cpu().numpy())
        
        # ä¿å­˜CSVæ ¼å¼ä¾¿äºæŸ¥çœ‹
        grid_data_np = grid_flat.cpu().numpy()
        np.savetxt('/tmp/python_grid_points.csv', grid_data_np, delimiter=',', 
                   header='X,Y,Z', comments='')
        
        print('Pythonæ•°æ®å·²ä¿å­˜åˆ° /tmp/python_*.npy å’Œ /tmp/python_*.csv')
    except Exception as e:
        print(f'ä¿å­˜æ•°æ®æ—¶å‡ºé”™: {e}')
    
    print('=== PYTHON EXECUTION COMPLETE ===')
    
    return {
        'grid_xyz': grid_xyz,
        'grid_flat': grid_flat,
        'beam_vector': p1_unit,
        'perpendicular_vectors': xl_unit,
        'beam_start': torch.tensor(B2_start, device=device, dtype=torch.float64).detach().clone(),  # è½¬æ¢ä¸ºtorch tensor
        'beam_end': torch.tensor(B2_end, device=device, dtype=torch.float64).detach().clone(),     # è½¬æ¢ä¸ºtorch tensor
        'beam_length': b2ls,  # æ€»é•¿åº¦
        'beam_step': b2ls_step,  # æ­¥é•¿
    }


def compute_beam_path_center(Figure 5: å…‰æŸä½ç½®æˆªé¢å›¾

    beam_config: BeamConfig,
    device: str = 'cuda',
    beam_grid: Dict[str, torch.Tensor] = None
) -> torch.Tensor:
    """
    è®¡ç®—å…‰æŸä¸­å¿ƒè·¯å¾„çš„é‡‡æ ·ç‚¹
    
    ä¸¥æ ¼æŒ‰ç…§MATLAB LSview_com.m è¡Œ155-158å®ç°
    ä»ç½‘æ ¼ä¸­æå–ä¸­å¿ƒè·¯å¾„: xls(div1+1, div2+1, :)
    
    Args:
        beam_config: å…‰æŸé…ç½®
        device: PyTorchè®¾å¤‡
        beam_grid: compute_beam_gridçš„è¾“å‡ºï¼ˆå¯é€‰ï¼Œå¦‚æœä¸æä¾›åˆ™è®¡ç®—ï¼‰
    
    Returns:
        (divls+1, 3) ä¸­å¿ƒè·¯å¾„åæ ‡
    """
    # å¦‚æœæ²¡æœ‰æä¾›beam_gridï¼Œåˆ™è®¡ç®—å®ƒ
    if beam_grid is None:
        beam_grid = compute_beam_grid(beam_config, device=device)
    
    # MATLAB ç¬¬155-158è¡Œ: ä»ç½‘æ ¼ä¸­æå–ä¸­å¿ƒè·¯å¾„
    # xls_c(:,1)=squeeze(xls(div1+1,div2+1,:))
    # xls_c(:,2)=squeeze(yls(div1+1,div2+1,:))
    # xls_c(:,3)=squeeze(zls(div1+1,div2+1,:))
    div1 = beam_config.div_vertical
    div2 = beam_config.div_toroidal
    
    grid_xyz = beam_grid['grid_xyz']  # (div1_2, div2_2, divls_2, 3)
    
    # MATLAB ç´¢å¼•ä»1å¼€å§‹ï¼Œæ‰€ä»¥ div1+1 å¯¹åº” Python çš„ div1
    # å› ä¸º div1_2 = 2*div1+1ï¼Œæ‰€ä»¥ä¸­å¿ƒç´¢å¼•æ˜¯ div1
    center_path = grid_xyz[div1, div2, :, :]  # (divls_2, 3)
    
    return center_path


def get_detector_positions(
    beam_config: BeamConfig,
    device: str = 'cuda',
    beam_grid: Dict[str, torch.Tensor] = None
) -> Tuple[torch.Tensor, torch.Tensor]:
    """
    è·å–æ£€æµ‹å™¨é˜µåˆ—çš„ä½ç½®
    
    ä¸¥æ ¼æŒ‰ç…§MATLAB LSview_com.m è¡Œ212-213å®ç°
    [xx1,yy1]=meshgrid(wid1/2*[-div1:div1]/div1,-wid2/2*[-div2:div2]/div2);
    xx1 = fliplr(xx1);
    
    æ³¨æ„ï¼šæ ¹æ®ä¿®æ­£åçš„å…‰æŸç½‘æ ¼é€»è¾‘ï¼Œæ£€æµ‹å™¨ä½ç½®éœ€è¦ä»å…‰æŸè·¯å¾„çš„ç»ˆç‚¹æå–
    
    Args:
        beam_config: å…‰æŸé…ç½®
        device: PyTorchè®¾å¤‡
        beam_grid: compute_beam_gridçš„è¾“å‡ºï¼ˆå¯é€‰ï¼Œå¦‚æœä¸æä¾›åˆ™è®¡ç®—ï¼‰
    
    Returns:
        (detector_coords, detector_grid):
            - detector_coords: (div1*2+1, div2*2+1, 3) æ£€æµ‹å™¨3Dåæ ‡
            - detector_grid: (div1*2+1, div2*2+1, 2) æ£€æµ‹å™¨ç½‘æ ¼ (yy1, xx1_flipped)
    """
    div1 = beam_config.div_vertical
    div2 = beam_config.div_toroidal
    wid1 = beam_config.width_vertical
    wid2 = beam_config.width_toroidal
    
    # MATLAB ç¬¬212è¡Œ: meshgrid(wid1/2*[-div1:div1]/div1, -wid2/2*[-div2:div2]/div2)
    # wid1/2*[-div1:div1]/div1 ç”Ÿæˆä» -wid1/2 åˆ° wid1/2 çš„æ•°ç»„ï¼Œå…± 2*div1+1 ä¸ªç‚¹
    # -wid2/2*[-div2:div2]/div2 ç”Ÿæˆä» wid2/2 åˆ° -wid2/2 çš„æ•°ç»„ï¼ˆæ³¨æ„è´Ÿå·ï¼‰ï¼Œå…± 2*div2+1 ä¸ªç‚¹
    
    # ç”Ÿæˆ x åæ ‡ï¼ˆå¯¹åº” MATLAB çš„ç¬¬ä¸€ä¸ªå‚æ•°ï¼‰
    x_coords = torch.tensor([wid1/2.0 * (i - div1) / div1 for i in range(2*div1+1)], 
                            dtype=torch.float64, device=device).detach().clone()
    # ç”Ÿæˆ y åæ ‡ï¼ˆå¯¹åº” MATLAB çš„ç¬¬äºŒä¸ªå‚æ•°ï¼Œæ³¨æ„è´Ÿå·ï¼‰
    y_coords = torch.tensor([-wid2/2.0 * (i - div2) / div2 for i in range(2*div2+1)], 
                            dtype=torch.float64, device=device).detach().clone()
    
    # MATLAB çš„ meshgrid: [xx1, yy1] = meshgrid(x, y)
    # å…¶ä¸­ x æ˜¯åˆ—å‘é‡ï¼Œy æ˜¯è¡Œå‘é‡
    # xx1 çš„æ¯ä¸€è¡Œéƒ½æ˜¯ xï¼Œyy1 çš„æ¯ä¸€åˆ—éƒ½æ˜¯ y
    # åœ¨ Python ä¸­ï¼Œä½¿ç”¨ indexing='xy' æ¥åŒ¹é… MATLAB çš„è¡Œä¸º
    xx1, yy1 = torch.meshgrid(x_coords, y_coords, indexing='xy')
    
    # MATLAB ç¬¬213è¡Œ: xx1 = fliplr(xx1) - å·¦å³ç¿»è½¬
    xx1_flipped = torch.flip(xx1, dims=[1])
    
    # å †å æˆç½‘æ ¼ (div1_2, div2_2, 2)
    detector_grid = torch.stack([yy1, xx1_flipped], dim=-1)
    
    # æ£€æµ‹å™¨çš„3Dä½ç½®ï¼šä»å…‰æŸç½‘æ ¼ä¸­æå–
    # ä¿®æ­£: æ ¹æ®æ–°çš„å…‰æŸç½‘æ ¼é€»è¾‘ï¼š
    # - ç½‘æ ¼ä»æ³¨å…¥ç‚¹(B2_start)å¼€å§‹åˆå§‹åŒ–
    # - æ·»åŠ å‚ç›´æ–¹å‘çš„åç§»
    # - å…‰æŸæ–¹å‘çš„åç§»ä»0å¼€å§‹ï¼Œåœ¨ç»ˆç‚¹ç»“æŸ
    # æ‰€ä»¥æ£€æµ‹å™¨ä½ç½® = grid_xyz[:, :, -1]ï¼ˆå…‰æŸæ–¹å‘çš„æœ€åä¸€ä¸ªç´¢å¼•ï¼‰
    if beam_grid is None:
        beam_grid = compute_beam_grid(beam_config, device=device)
    
    grid_xyz = beam_grid['grid_xyz']  # (div1_2, div2_2, divls_2, 3)
    
    # æå–æ£€æµ‹å™¨ä½ç½®ï¼šå…‰æŸæ–¹å‘çš„æœ€åä¸€ä¸ªç´¢å¼•ï¼ˆoffset=0ï¼‰
    detector_coords = grid_xyz[:, :, -1, :]  # (div1_2, div2_2, 3)
    
    return detector_coords, detector_grid


def visualize_beam_geometry(
    beam_grid: Dict[str, torch.Tensor],
    config: GENEConfig = None,
    save_path: str = None
):
    """
    å¯è§†åŒ–å…‰æŸå‡ ä½•ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    
    Args:
        beam_grid: compute_beam_gridçš„è¾“å‡º
        config: GENEé…ç½®ï¼ˆå¯é€‰ï¼Œç”¨äºæ˜¾ç¤ºæ‰˜å¡é©¬å…‹è¾¹ç•Œï¼‰
        save_path: ä¿å­˜è·¯å¾„ï¼ˆå¯é€‰ï¼‰
    """
    try:
        import matplotlib.pyplot as plt
        from mpl_toolkits.mplot3d import Axes3D
    except ImportError:
        print("éœ€è¦matplotlibè¿›è¡Œå¯è§†åŒ–")
        return
    
    fig = plt.figure(figsize=(12, 8))
    ax = fig.add_subplot(111, projection='3d')
    
    # ç»˜åˆ¶å…‰æŸè·¯å¾„
    grid = beam_grid['grid_xyz'].cpu().numpy()
    div1, div2, divls, _ = grid.shape
    
    # ç»˜åˆ¶ä¸­å¿ƒçº¿
    center = grid[div1//2, div2//2, :, :]
    ax.plot(center[:, 0], center[:, 1], center[:, 2], 'r-', linewidth=2, label='Beam center')
    
    # ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
    start = beam_grid['beam_start'].cpu().numpy()
    end = beam_grid['beam_end'].cpu().numpy()
    ax.scatter([start[0], end[0]], [start[1], end[1]], [start[2], end[2]], 
               c='red', s=100, marker='o', label='Start/End')
    
    # é‡‡æ ·ä¸€äº›å…‰æŸçº¿
    for i in range(0, div1, max(1, div1//2)):
        for j in range(0, div2, max(1, div2//2)):
            line = grid[i, j, ::10, :]  # æ¯10ä¸ªç‚¹é‡‡æ ·ä¸€æ¬¡
            ax.plot(line[:, 0], line[:, 1], line[:, 2], 'b.', alpha=0.3, markersize=1)
    
    # å¦‚æœæœ‰é…ç½®ï¼Œç»˜åˆ¶æ‰˜å¡é©¬å…‹è¾¹ç•Œ
    if config is not None and config.GRC is not None:
        GRC = config.GRC.cpu().numpy()
        GZC = config.GZC.cpu().numpy()
        
        # ç»˜åˆ¶å‡ æ¡poloidalæˆªé¢
        n_phi = 8
        for i_phi in range(n_phi):
            phi = i_phi * 2 * np.pi / n_phi
            x_torus = GRC[-1, :] * np.cos(phi)
            y_torus = GRC[-1, :] * np.sin(phi)
            z_torus = GZC[-1, :]
            ax.plot(x_torus, y_torus, z_torus, 'k-', alpha=0.5, linewidth=0.5)
    
    ax.set_xlabel('X (m)')
    ax.set_ylabel('Y (m)')
    ax.set_zlabel('Z (m)')
    ax.legend()
    ax.set_title('PCI Beam Geometry')
    
    if save_path:
        plt.savefig(save_path, dpi=150, bbox_inches='tight')
    else:
        plt.show()
    
    plt.close()


æ¥ä¸‹æ¥æ˜¯matlabï¼š
% detection along lines of sight
function [pout1, pout2] = LSview_com(sim,data_n,t,var)
% simulation type: 2(DISA),3(R4F),3.5(R5F),5(GENE)
% data#, time(0:time series), var
% using the condition file 'LS_condition.txt'
%
oldpath=path;
path('../com',oldpath);
f_path='path_matlab.txt';
%
switch sim
    case {'R5F', 'r5f'}
        FVER=3.5;
        oldpath=addpath('../sim_data/r5f','../sim_data/task_eq','../sim_data/r5f/plot');
        dataC=r5fClass(f_path,data_n);
    case {'MIPS', 'mips'}
        FVER=4;
        oldpath=addpath('../sim_data/mips','../sim_data/mips/plot');
        dataC=hibpClass_mips(f_path,data_n);
    case {'GENE', 'gene'}
        FVER=5;
        oldpath=addpath('../sim_data/GENE','../sim_data/task_eq','../sim_data/GENE/plot');
        dataC=GENEClass(f_path,data_n);
    otherwise
        error('Unexpected simulation type.')
end

%f_condition='./LS_condition.txt';
f_condition='./LS_condition_JT60SA.txt';

% for LS_condition_multi_line
%A=importdata(f_condition);
%num=A.data(1);
%(R,Z,phi)
%pp1=reshape(A.data(2:end),num,3);
%if FVER==1
%(R,Z,phi)->(r,theta,phi)
%pp2=zeros(num,3);
%pp2(:,1)=sqrt(pp1(:,1).^2+pp1(:,2).~2);
%pp2(:,2)=atan2(pp1(:,2),pp1(:,1));
%pp2(:,3)=pp1(:,3);
%end
%divls=50;
%
if FVER == 5   % To calculate obj.KYMt and obj.KZMt
    %Generate time data (00****.dat) from TORUSIons_act.dat
    GENEdata = sprintf('%sTORUSIons_act_%.0f.dat', dataC.indir, t*100)
    generate_timedata(dataC,GENEdata,t);
end
% for LS_condition_beam
fread_param2(dataC);
fread_EQ1(dataC);
%
A=importdata(f_condition,',',5);
if iscell(A)
    % Handle cell array format
    data1 = sscanf(A{1}, '%f,');
    data2 = sscanf(A{2}, '%f,');
    data3 = sscanf(A{3}, '%f,');
    pp1 = data1;
    wid1 = data2(1);
    wid2 = data2(2);
    div1 = data3(1);
    div2 = data3(2);
    divls = data3(3);
else
    % Handle struct format (original code)
    pp1=A.data(1,:);
    wid1=A.data(2,1);
    wid2=A.data(2,2);
    div1=A.data(3,1);
    div2=A.data(3,2);
    divls=A.data(3,3);
end
%
B1=zeros(2,3);
xl=zeros(2,3);
p1=zeros(3,1);
B1(1,:)=pp1(1:3);
B1(2,:)=pp1(4:6);
B2(:,1)=B1(:,1).*cos(2*pi*B1(:,3));
B2(:,2)=B1(:,1).*sin(2*pi*B1(:,3));
B2(:,3)=B1(:,2);
B2=B2/1000.0;
b2ls=(B2(1,1)-B2(2,1))*(B2(1,1)-B2(2,1)) ...
    +(B2(1,2)-B2(2,2))*(B2(1,2)-B2(2,2)) ...
    +(B2(1,3)-B2(2,3))*(B2(1,3)-B2(2,3));
b2ls=sqrt(b2ls);
%
p1(1)=B2(1,1)-B2(2,1);
p1(2)=B2(1,2)-B2(2,2);
p1(3)=B2(1,3)-B2(2,3);
%
if(p1(1)==0 && p1(2)==0)
    xl(1,1)=wid1/2.0*cos(2*pi*B1(1,3));
    xl(1,2)=wid1/2.0*sin(2*pi*B1(1,3));
    xl(1,3)=0.0;
    xl(2,1)=-wid2/2.0*sin(2*pi*B1(1,3));
    xl(2,2)=wid2/2.0*cos(2*pi*B1(1,3));
    xl(2,3)=0.0;
else
    xl(1,1)=p1(3);
    xl(1,2)=p1(3)*tan(2*pi*B1(1,3));
    xl(1,3)=-(p1(1)+p1(2)*tan(2*pi*B1(1,3)));
    xl0=1.0/sqrt(xl(1,1)^2+xl(1,2)^2+xl(1,3)^2)*wid1/2.0;
    xl(1,1)=xl(1,1)*xl0;
    xl(1,2)=xl(1,2)*xl0;
    xl(1,3)=xl(1,3)*xl0;
    xl(2,1)=p1(1)*p1(2)+(p1(2)^2+p1(3)^2)*tan(2*pi*B1(1,3));
    xl(2,2)=-p1(1)^2-p1(3)^2-p1(1)*p1(2)*tan(2*pi*B1(1,3));
    xl(2,3)=p1(2)*p1(3)-p1(1)*p1(3)*tan(2*pi*B1(1,3));
    xl0=1.0/sqrt(xl(2,1)^2+xl(2,2)^2+xl(2,3)^2)*wid2/2.0;
    xl(2,1)=xl(2,1)*xl0;
    xl(2,2)=xl(2,2)*xl0;
    xl(2,3)=xl(2,3)*xl0;
end
divls_2=divls+1;
div1_2=2*div1+1;
div2_2=2*div2+1;
num=div1_2*div2_2;
b2ls=b2ls/divls;
replix=zeros(div1_2,div2_2,divls_2);
xls=ones(div1_2,div2_2,divls_2)*B2(2,1);
yls=ones(div1_2,div2_2,divls_2)*B2(2,2);
zls=ones(div1_2,div2_2,divls_2)*B2(2,3);
%
for j=1:div1_2
    replix(j,:,:)=ones(div2_2,divls_2)*(real(j-1)-div1)/div1;
end
xls=xls+replix*xl(1,1);
yls=yls+replix*xl(1,2);
zls=zls+replix*xl(1,3);
for j=1:div2_2
    replix(:,j,:)=ones(div1_2,divls_2)*(real(j-1)-div2)/div2;
end
xls=xls+replix*xl(2,1);
yls=yls+replix*xl(2,2);
zls=zls+replix*xl(2,3);
for j=1:divls_2
    replix(:,:,j)=ones(div1_2,div2_2)*real(j-1)/divls;
end
xls=xls+replix*p1(1);
yls=yls+replix*p1(2);
zls=zls+replix*p1(3);
xls1=reshape(xls,div1_2*div2_2*divls_2,1);
yls1=reshape(yls,div1_2*div2_2*divls_2,1);
zls1=reshape(zls,div1_2*div2_2*divls_2,1);
%
%Plot the start and end points of the beam
figure(1)Figure 1: 3Då…‰æŸå‡ ä½•å›¾

plot3(B2(:,1),B2(:,2),B2(:,3),'o');
hold on
%
%Plot the path of the beam
plot3(xls1,yls1,zls1,'.');
%
%Plot the shape of the tokamak
xls_b=dataC.GRC(end,:).'*cos([0:30]*2*pi/30);
yls_b=dataC.GRC(end,:).'*sin([0:30]*2*pi/30);
zls_b=repmat(dataC.GZC(end,:).',1,31);
%plot3(xls_b,yls_b,zls_b,'k-');
plot3(xls_b(1:2:end,:).',yls_b(1:2:end,:).',zls_b(1:2:end,:).','k-');
%
xlabel("X")
ylabel("Y")
zlabel("Z")
hold off
%
xls_c=zeros(divls_2,3);
xls_c(:,1)=squeeze(xls(div1+1,div2+1,:));
xls_c(:,2)=squeeze(yls(div1+1,div2+1,:));
xls_c(:,3)=squeeze(zls(div1+1,div2+1,:));
xl_c(1,:)=xl(1,:)/norm(xl(1,:));
xl_c(2,:)=xl(2,:)/norm(xl(2,:));
%{
plot3(xls_c(:,1),xls_c(:,2),xls_c(:,3));
%plot3(xls_c(1:10,1),xls_c(1:10,2),xls_c(1:10,3),'o');
hold on
quiver3(xls_c(1,1),xls_c(1,2),xls_c(1,3),xl_c(1,1),xl_c(1,2),xl_c(1,3))
quiver3(xls_c(1,1),xls_c(1,2),xls_c(1,3),xl_c(2,1),xl_c(2,2),xl_c(2,3))
plot3(xls_b,yls_b,zls_b,'k-');
plot3(xls_b.',yls_b.',zls_b.','k-');
hold off
%}
%
LSmag(dataC,divls_2,xls_c,p1);
%
r1=sqrt(xls.*xls+yls.*yls);
phi1=atan2(yls,xls);
%
num1=num*divls_2;
r_p=reshape(r1,num1,1);
zls2=reshape(zls,num1,1);
phi_p=reshape(phi1,num1,1);
%
x1=zeros(num1,3);
x1(:,1)=r_p;
x1(:,2)=zls2;
x1(:,3)=phi_p;
%
if FVER == 5   % GENE
    [pout,R,Z]=probe_multi2(sim,data_n,t,num1,x1,var,p1); %using p1 to calculate beam vector
else
    pout=probe_multi(sim,data_n,t,num1,x1,var);
end
%{
% multi fluctuation
if FVER == 5
    n = 0;
    data_n2 = input('data_n = (Enter 0 to exit.)');
    while data_n2 ~= 0
        n = n + 1;
        data_nlist(n) = data_n2
        data_n2 = input('data_n = (Enter 0 to exit.)');
    end
    [pout,R,Z]=probe_multi3(sim,data_nlist,t,num1,x1,var,p1,n); %using p1 to calculate beam vector
else
    pout=probe_multi(sim,data_n,t,num1,x1,var);
end
%}
if (t~=0)
    pout1=reshape(pout,div1_2,div2_2,divls_2);
    %Line of sight integration
    pout2=sum(pout1,3);
    %
    [xx1,yy1]=meshgrid(wid1/2*[-div1:div1]/div1,-wid2/2*[-div2:div2]/div2);
    xx1 = fliplr(xx1);

    figure(3)
    contourf(yy1.',xx1.',pout2,100,'LineStyle','none');
    shading flat;
    axis equal;
    colorbar
    xlabel('x (m)');
    ylabel('y (m)');
    
    %figure3_path = sprintf('%s%s%s%d',dataC.indir,'figure/','figure3_',t*100)
    %saveas(figure(3),figure3_path)
end
%
%2D Fourier Transform
figure(4)
plotWaveNumberSpace(yy1.',xx1.',pout2,dataC)

% === è°ƒè¯•æ•°æ®ä¿å­˜ ===
% ä¿å­˜é»„é‡‘æ ‡å‡†æ•°æ®ä¾›Pythonå¯¹æ¯”
fprintf('\n=== ä¿å­˜é»„é‡‘æ ‡å‡†æ•°æ® ===\n');

% æ„é€ ä¸probe_multi2ç›¸åŒçš„p3æ•°æ®
str = sprintf('%s%08d.dat',dataC.indir,t*100);
p2 = fread_data_s(5,dataC,str);
% p3 = squeeze(p2(:,:,:,var));  % p2åªæœ‰3ç»´ï¼Œvar=4è¶…å‡ºè¾¹ç•Œ
p3 = p2;  % ç›´æ¥ä½¿ç”¨p2ä½œä¸ºå¯†åº¦æ•°æ®

% ä¿å­˜å…³é”®æ•°æ®
density_data_matlab = p3;              % çœŸæ­£çš„3Då¯†åº¦æ•°æ®
GAC_matlab = dataC.GAC;                % ç­‰ç¦»å­ä½“è¾¹ç•Œ
GTC_c_matlab = dataC.GTC_c;            % åæ ‡è½¬æ¢
philist_matlab = linspace(0, 1, dataC.KZMt + 2); % phiåæ ‡
PA_matlab = dataC.PA;                  % ç­‰ç¦»å­ä½“è½´
L_ref_matlab = dataC.L_ref;            % å‚è€ƒé•¿åº¦

% ä¿å­˜åˆ°æ–‡ä»¶
save('debug_data.mat', ...
     'density_data_matlab', 'GAC_matlab', 'GTC_c_matlab', ...
     'philist_matlab', 'PA_matlab', 'L_ref_matlab');

fprintf('âœ… é»„é‡‘æ ‡å‡†æ•°æ®å·²ä¿å­˜åˆ° debug_data.mat\n');
fprintf('  å¯†åº¦èŒƒå›´: [%.6e, %.6e]\n', min(density_data_matlab(:)), max(density_data_matlab(:)));
fprintf('  å½¢çŠ¶: density(%d,%d,%d), GAC(%d,%d), philist(%d,)\n', ...
        size(density_data_matlab,1), size(density_data_matlab,2), size(density_data_matlab,3), ...
        size(GAC_matlab,1), size(GAC_matlab,2), length(philist_matlab));

end


% plot a time evolution of any profile
function [pout,R,Z]=probe_multi2(sim,data_n,t,num1,x1,var,p1)
% simulation type: 5(GENE)
% data#, time, probe#, positions
% var(1:potential,2:A,3:v,4:n,5:Te)
%
oldpath=path;
path('../com',oldpath);
f_path='path_matlab.txt';
%
switch sim
    case {'GENE', 'gene'}
        FVER=5;
        dataC=GENEClass(f_path,data_n);
    otherwise
        error('Unexpected simulation type.')
end
%
%Generate time data (00****.dat) from TORUSIons_act.dat
GENEdata = sprintf('%sTORUSIons_act_%d.dat', dataC.indir, round(t*100));
generate_timedata(dataC,GENEdata,t);
% parameters
fread_param2(dataC);
%
if(FVER ~= dataC.FVER)
         error('Simulation type mismatch (PARAM).')
end  
%
fread_EQ1(dataC);
%
% time series
if t == 0
fread_ptprflist(dataC);
%
tt=1;
TCS=input('from = ');
TCE=input('to = ');
TIN=input('interval = ');
TCS=TCS*100;
TCE=TCE*100;
TIN=TIN*100;
for b=1:dataC.COUNT
if (dataC.TIME(b)>=TCS && dataC.TIME(b)<=TCE && mod(dataC.TIME(b),TIN)==0)
t=dataC.TIME(b)/100;
timep(tt)=t;
tt=tt+1;
end
end
tnum=tt-1;
pout=zeros(tnum,num1);
%
for b=1:tnum
str=sprintf('%s%08d.dat',dataC.indir,timep(b)*100)
p2=fread_data_s(5,dataC,str);
p3=squeeze(p2(:,:,:,var));
for a=1:num1
pout(b,a)=probeEQ_local_s(dataC,x1(a,1),x1(a,2),x1(a,3),p3);
end
end
%
t=timep;
y=[1:num1];
[tt,yy]=meshgrid(t,y);
contourf(tt,yy,pout.',30,'LineStyle','none');
shading flat;
title('probe');
xlabel('t');
ylabel('position');
axis tight
colorbar
%
str=sprintf('%sprobe_%03d_%08d.dat',dataC.outdir,data_n,num1)
save(str,'timep','num1','x1','pout');
%
else
pout=zeros(num1,1);
R=zeros(num1,1);
Z=zeros(num1,1);
str=sprintf('%s%08d.dat',dataC.indir,round(t*100))

p2=fread_data_s(5,dataC,str);
p2_s=zeros(dataC.LYM2/(dataC.KZMt+1), dataC.nx0+1, dataC.KZMt+1+1);

for i = 1:dataC.KZMt+1
    p2_s(:,:,i)=[p2(:,:,i),zeros(length(p2),1,1)];
end
p2_s(:,:,end) = p2_s(:,:,1);

data2=zeros(dataC.LYM2/(dataC.KZMt+1), dataC.nx0+1+dataC.inside+dataC.outside,dataC.KZMt+1+1);

% overall
data2(:,dataC.inside+1:end-dataC.outside,:) = p2_s;

% inside (strong) only
%data2(1:100,dataC.inside+1:end-dataC.outside,:) = p2_s(1:100,:,:);
%data2(301:400,dataC.inside+1:end-dataC.outside,:) = p2_s(301:400,:,:);

% outside (weak) only
%data2(100:300,dataC.inside+1:end-dataC.outside,:) = p2_s(100:300,:,:);

data3=zeros(size(data2,1),size(data2,2),size(data2,3));
for i = 1:dataC.NTGMAX
    md = mod(i+(dataC.NTGMAX/2),dataC.NTGMAX);
    data3(md+1,:,:) = data2(i,:,:);
end
data3 = [data3; data3(1,:,:)];

loc=zeros(num1,1);
nonloc=zeros(num1,1);
xx = NaN(num1,1);
yy = NaN(num1,1);
ang = NaN(num1,1);
ang2 = NaN(num1,1);
non_xx = NaN(num1,1);
non_yy = NaN(num1,1);
non_ang = NaN(num1,1);
non_ang2 = NaN(num1,1);

% Lx, Ly and Lz are beam vectors
Lx = [-p1(2)/p1(1); 1; 0]/((-p1(2)/p1(1))^2+1)^(1/2);
Ly = [p1(1)/p1(2); 1; -(p1(1)^2+p1(2)^2)/(p1(2)*p1(3))]/((p1(1)/p1(2))^2+1+(-(p1(1)^2+p1(2)^2)/(p1(2)*p1(3)))^2)^(1/2);
Lz = p1/(p1(1)^2+p1(2)^2+p1(3)^2)^(1/2);
%
for a=1:num1
    pout(a)=probeEQ_local_s(dataC,x1(a,1),x1(a,2),x1(a,3),data3);
    R(a) = x1(a,1);
    Z(a) = x1(a,2);
    %
    if pout(a)~=0
        loc(a)=probeEQ_rho(dataC,x1(a,1),x1(a,2),x1(a,3));
        nonloc(a)=NaN;
        [xx(end-a+1), yy(end-a+1), ang(end-a+1), ang2(end-a+1)] = LSmag2(dataC,x1(a,1),x1(a,2),x1(a,3),Lx,Ly,Lz);
    else 
        loc(a)=NaN;
        nonloc(a)=probeEQ_rho(dataC,x1(a,1),x1(a,2),x1(a,3));
        [non_xx(end-a+1), non_yy(end-a+1), non_ang(end-a+1), non_ang2(end-a+1)] = LSmag2(dataC,x1(a,1),x1(a,2),x1(a,3),Lx,Ly,Lz);
    end
end

figure(2)Figure 2: PCIä¿¡å·å¼ºåº¦å›¾

plot(abs(pout));
%
figure(21)
plot(loc,".b")
hold on
plot(nonloc,".r")
hold off
ylim([0,1])
xlabel('beam path')
ylabel('Ï')
minmax = sprintf('Ï_{min} = %.2f , Ï_{max} = %.2f',min(loc), max(loc));
title(minmax);
legend("With fluctuation","Without fluctuation",'Location', 'Best')
%
figure(301)
plot(yy,".b")
hold on
plot(non_yy,".r")
hold off 
xlabel('beam path')
ylabel('By')
legend("With fluctuation","Without fluctuation",'Location', 'Best')

figure(302)
plot(xx,".b")
hold on
plot(non_xx,".r")
hold off 
xlabel('beam path')
ylabel('Bx')
legend("With fluctuation","Without fluctuation",'Location', 'Best')

figure(303)
plot(ang,".b")
hold on
plot(non_ang,".r")
hold off 
xlabel('beam path')
ylabel('theta')
legend("With fluctuation","Without fluctuation",'Location', 'Best')

figure(304)
plot(ang2,".b")
hold on
plot(non_ang2,".r")
hold off 
xlabel('beam path')
ylabel('theta cutout')
legend("With fluctuation","Without fluctuation",'Location', 'Best')
%
end
%
end

%generate 2D wavenumber spectrum
function Amp = plotWaveNumberSpace(xx, yy, realSpaceData,obj)

    Mean = mean(mean(realSpaceData(:)));

    realSpaceData = realSpaceData - Mean;
    [Ny, Nx] = size(realSpaceData);
    P = fft2(realSpaceData);
    P_shifted = fftshift(P);
    Amp = abs(P_shifted);

    dx = (xx(1,2) - xx(1,1));
    dy = (yy(2,1) - yy(1,1));

    if mod(Nx, 2) == 0
        kx = 2*pi*(-Nx/2:Nx/2-1)/((Nx-1)*dx);
    else
        kx = 2*pi*(-(Nx-1)/2:(Nx-1)/2)/((Nx-1)*dx);
    end

    if mod(Ny, 2) == 0
        ky = 2*pi*(-Ny/2:Ny/2-1)/((Ny-1)*dy);
    else
        ky = 2*pi*(-(Ny-1)/2:(Ny-1)/2)/((Ny-1)*dy);
    end

    [KX, KY] = meshgrid(kx, ky);

    %normalized
    if obj.FVER == 5 %GENE
        kx = kx*obj.rho_ref;
        ky = ky*obj.rho_ref;
        KX = KX*obj.rho_ref;
        KY = KY*obj.rho_ref;
    else
        kx = kx*0.003;
        ky = ky*0.003;
        KX = KX*0.003;
        KY = KY*0.003;
    end
    %
    contourf(KX, KY, log(Amp), 100, 'LineStyle', 'none');
    xlabel('k_xÏ_i')
    ylabel('k_yÏ_i')
    colorbar;
    %
end



%display the detection position
function LS_location(obj,x,y,z,div1,div2,div3)

    r = (x.^2 + y.^2).^(1/2);
    R = reshape(r,div1,div2,div3);
    Z = reshape(z,div1,div2,div3);
    
    zls_b=repmat(obj.GZC(end,:).',1,31);
    %
    figure(5)
    plot(obj.GRC(end,:),zls_b,'k-');
    axis equal;
    hold on
    
    for i = 1:div3
        plot(R((div1+1)/2,:,i),Z((div1+1)/2,:,i),'r.')
        title('beam path')
    end
    hold off
end

mlä¸­å‡ºå›¾ä»£ç ä½ç½®å¾ˆåˆ†æ•£ï¼Œæœ‰å¯èƒ½æˆ‘çš„æ³¨é‡Šæ ‡æ³¨æœ‰é—®é¢˜ï¼Œä¸»è¦ä»¥figure 1 2 3 4 5çš„æ•°å­—çœ‹é½ï¼š

æˆ‘çš„è¦æ±‚æ˜¯ï¼Œç°åœ¨pyè·Ÿmlä»£ç å¯¹ä¸ä¸Šï¼Œæˆ‘ä»¬ä¸€æ­¥ä¸€æ­¥è°ƒè¯•ï¼Œå°†è¾“å‡ºæ—¥å¿—æ•°æ®ï¼Œå¯¹æ¯”pyå’Œmlçš„æ•°æ®ï¼Œæ¯ä¸€æ­¥ç›´åˆ°æ•°æ®ä¸€è‡´åï¼Œæ‰è¿›è¡Œä¸‹ä¸€æ­¥ï¼Œç»™æˆ‘åˆ¶å®šè¿™ä¸ªè®¡åˆ’ï¼š