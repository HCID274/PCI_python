# PyPCI 可视化系统详细流程图

## 出图完整流程图

```mermaid
graph TD
    A[开始运行PBS任务] --> B[激活Python环境]
    B --> C[加载配置文件]
    C --> D[run_pci.py 主入口]
    D --> E[run_single_time 函数]
    
    E --> F[加载GENE配置]
    F --> G[加载光束配置]
    G --> H[读取密度场数据]
    
    H --> I[PCI正向投影]
    I --> J[调用forward_projection]
    
    J --> K[生成光束网格]
    K --> L[坐标转换]
    L --> M[三线性插值]
    M --> N[沿光束积分]
    N --> O[生成检测器信号]
    
    O --> P{是否保存详细结果?}
    P -->|是| Q[初始化PCIVisualizer]
    P -->|否| R[保存基本结果]
    
    Q --> S[图1: 3D光束几何图]
    S --> T[图2: 密度场截面图]
    T --> U[图3: 检测器信号图]
    U --> V[图4: 波数空间图]
    
    V --> W[保存所有图像]
    W --> X[生成分析报告]
    X --> Y[任务完成]
    
    R --> Y
```

## 4个主要图像的详细计算流程

### 图1: 3D光束几何图计算流程

```mermaid
graph LR
    A[plot_beam_geometry_3d] --> B[compute_beam_grid]
    B --> C[读取注入点配置]
    C --> D[笛卡尔坐标转换]
    D --> E[生成检测器网格]
    E --> F[计算光束方向向量]
    F --> G[绘制光束路径点]
    G --> H[绘制中心线]
    H --> I[绘制起止点]
    I --> J[绘制托卡马克边界]
    J --> K[保存PNG图像]
```

**核心数据流**:
- 输入: BeamConfig, device
- 计算: (R, Z, phi) → (X, Y, Z) 坐标转换
- 输出: 9×25×3000 个3D点 + 边界信息

### 图2: 密度场Poloidal截面图计算流程

```mermaid
graph LR
    A[plot_density_slice] --> B[提取3D密度场]
    B --> C[磁通坐标转换]
    C --> D[生成poloidal网格]
    D --> E[二维插值]
    E --> F[等高线计算]
    F --> G[颜色映射]
    G --> H[叠加边界]
    H --> I[保存PNG图像]
```

**核心数据流**:
- 输入: density_3d (ntheta, nx, nz), GENEConfig
- 计算: 3D→2D切片 + 坐标转换 + 插值
- 输出: 2D等高线图 + 托卡马克几何

### 图3: 检测器信号等高线图计算流程

```mermaid
graph LR
    A[plot_detector_contour] --> B[PCI正向投影结果]
    B --> C[信号后处理]
    C --> D[归一化滤波]
    D --> E[生成空间网格]
    E --> F[等高线图绘制]
    F --> G[添加颜色条]
    G --> H[叠加几何信息]
    H --> I[保存PNG图像]
```

**核心数据流**:
- 输入: pci_result (n_det_v, n_det_t)
- 计算: 信号处理 + 2D网格生成
- 输出: 2D等高线图 + 检测器布局

### 图4: 2D波数空间图计算流程

```mermaid
graph LR
    A[plot_wavenumber_space_2d] --> B[PCI信号输入]
    B --> C[2D FFT计算]
    C --> D[波数域映射]
    D --> E[幅值谱计算]
    E --> F[频域可视化]
    F --> G[主要模式标注]
    G --> H[对称性分析]
    H --> I[保存PNG图像]
```

**核心数据流**:
- 输入: pci_result, 空间网格坐标
- 计算: FFT + 波数域转换
- 输出: 2D频谱图 + 模式信息

## 时间序列分析的可视化流程

```mermaid
graph TD
    A[complete_pipeline.py] --> B[批量时间序列处理]
    B --> C[process_time_series]
    C --> D[find_time_data_files]
    D --> E[逐个时间点处理]
    E --> F[保存时间序列结果]
    F --> G[FFT频谱分析]
    G --> H[FFT3DAnalyzer]
    H --> I[3D FFT计算]
    I --> J[kx-ky频谱]
    J --> K[ω-ky频谱]
    K --> L[ω-kx频谱]
    L --> M[时间快照分析]
    M --> N[2D FFT平均]
    N --> O[批量生成图像]
    O --> P[生成分析报告]
```

## 关键计算节点说明

### 光束几何计算 (beam_geometry.py)
```python
def compute_beam_grid():
    # 1. 坐标转换: (R, Z, phi) → (X, Y, Z)
    B2 = convert_cylindrical_to_cartesian(B1)
    
    # 2. 光束向量计算
    p1 = B2_start - B2_end  # 光束方向
    p1_unit = p1 / |p1|     # 单位向量
    
    # 3. 垂直向量计算
    xl = calculate_perpendicular_vectors(p1, phi)
    
    # 4. 网格点生成
    grid = generate_probe_grid(B2_start, p1_unit, xl, wid1, wid2, div1, div2, divls)
    
    return grid  # (div1*2+1, div2*2+1, divls+1, 3)
```

### PCI正向投影 (forward_model.py)
```python
def forward_projection():
    # 1. 光束网格生成
    beam_grid = compute_beam_grid(beam_config, device)
    
    # 2. 坐标转换
    R, Z, PHI = cartesian_to_flux(grid_xyz, gene_config)
    
    # 3. 插值采样
    local_values = trilinear_interpolation(density_3d, R, Z, PHI)
    
    # 4. 沿光束积分
    line_integral = torch.sum(local_values, dim=-1)
    
    # 5. 2D检测器信号
    detector_signal = line_integral.view(n_det_v, n_det_t)
    
    return detector_signal
```

### 3D FFT分析 (fft_analysis.py)
```python
def FFT3DAnalyzer():
    # 1. 数据加载
    realSpaceData = load_time_series()  # (Ny, Nx, Nt)
    
    # 2. 3D FFT
    Amp = fftn(realSpaceData)  # (Ny, Nx, Nt)
    
    # 3. 波数域坐标
    kx, ky, f = generate_wavenumber_grids()
    
    # 4. 频谱分析模式
    # - kx-ky: 固定频率切片
    # - ω-ky: 固定kx切片  
    # - ω-kx: 固定ky切片
    # - 时间快照: 固定时间
    # - 2D FFT: 时间平均
```

## 性能关键路径

### GPU计算路径
```mermaid
graph LR
    A[PyTorch张量] --> B[GPU内存分配]
    B --> C[CUDA/ROCm核函数]
    C --> D[并行矩阵运算]
    D --> E[自动微分]
    E --> F[结果回传CPU]
```

### 内存优化路径
```mermaid
graph LR
    A[大数据分块] --> B[流式处理]
    B --> C[内存映射文件]
    C --> D[缓存管理]
    D --> E[垃圾回收]
    E --> F[内存池]
```

这个详细的流程图展示了PyPCI从数据输入到图像输出的每一个步骤，特别是重点说明了4个主要图像的生成流程和计算细节。
